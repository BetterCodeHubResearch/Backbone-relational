{"version":3,"sources":["backbone-relational.min.js","/source/utils/semaphore.js","/source/utils/blocking-queue.js","/source/event-queue.js","/source/utils/extend.js","/source/utils/events.js","/source/utils/object.js","/source/config.js","/source/backbone-relational.js"],"names":["global","factory","exports","module","require","define","amd","BackboneRelational","Backbone","_","this","Backbone__default","Semaphore","_permitsAvailable","_permitsUsed","acquire","Error","release","isLocked","setAvailablePermits","amount","BlockingQueue","_queue","extend","prototype","add","func","isBlocked","push","process","queue","length","shift","block","unblock","eventQueue","Model","Events","extendableObject","_initialize","_len","arguments","args","Array","_key","initialize","call","apply","concat","config","showWarnings","Collection","Store","BObject","_collections","_reverseRelations","_orphanRelations","_subModels","_modelScopes","window","initializeRelation","model","relation","options","type","isString","getObjectByName","Relation","module$1","console","warn","addModelScope","scope","removeModelScope","without","addSubModels","subModelTypes","superModelType","subModels","setupSuperModel","modelType","find","subModelDef","filter","subModelTypeName","typeValue","subModelType","_superModel","_subModelTypeValue","_subModelTypeAttribute","subModelTypeAttribute","addReverseRelation","exists","any","rel","all","val","key","_addRelation","retroFitRelation","addOrphanRelation","processOrphanRelations","each","slice","relatedModel","store","relations","subModel","coll","getCollection","create","constructor","rootModel","item","_createCollection","name","parts","split","reduce","memo","undefined","resolveIdForItem","id","isNumber","isObject","idAttribute","obj","get","register","modelColl","collection","checkId","duplicate","update","contains","_onModelEvent","trigger","unregister","models","clone","stopListening","invoke","getRelations","reset","remove","createModels","includeInJSON","isAutoRelation","autoFetch","parse","instance","keyContents","relatedCollection","reverseRelation","related","opts","defaults","keySource","keyDestination","isUndefined","isFunction","result","checkPreconditions","contentKey","setKeyContents","attributes","_relations","getAsync","listenTo","destroy","tryAddRelated","removeRelated","i","k","m","rm","HasMany","keys","existing","setRelated","_isReverseRelation","getReverseRelations","reverseRelations","j","HasOne","_prepareCollection","onChange","findRelated","addRelated","findOrCreate","keyId","attr","changed","__related","oldRelated","silent","dit","collectionType","collectionKey","collectionOptions","handleAddition","handleRemoval","handleReset","toAdd","set","keyIds","difference","pluck","isArray","itemId","_isInitialized","_deferProcessing","_attributeChangeFired","processQueue","off","on","defer","eventName","indexOf","hasChanged","getRelation","initializeRelations","updateRelations","changedAttrs","value","values","getIdsToFetch","refresh","ids","requests","idsToFetch","setUrl","createdModels","map","findModel","attrs","url","defaultUrl","error","fetch","deferArray","then","_deferArray","$","when","newId","initializeModelHierarchy","toJSON","json","curJson","wait","setup","superModel","hasOwnProperty","preInitialize","build","_findSubModelType","inheritRelations","resolvedSubModels","unresolvedSubModels","omit","isNull","inheritedRelations","superRel","parsedAttributes","merge","__prepareModel","_prepareModel","validationError","__set","singular","newModels","cid","_byId","_removeModels","___removeModels","toRemove","__reset","sort","__sort","__trigger","toArray","protoProps","classProps","child"],"mappings":";;;;;;;;CAUC,SAAUA,EAAQC,GACE,gBAAZC,UAA0C,mBAAXC,QAAyBA,OAAOD,QAAUD,EAAQG,QAAQ,YAAaA,QAAQ,eACnG,kBAAXC,SAAyBA,OAAOC,IAAMD,QAAQ,WAAY,cAAeJ,GAC/ED,EAAOO,mBAAqBN,EAAQD,EAAOQ,SAASR,EAAOS,IAC5DC,KAAM,SAAUF,EAASC,GAAK,YAE9B,IAAIE,GAAoB,WAAaH,GAAWA,EAAS,WAAaA,CACtEC,GAAI,WAAaA,GAAIA,EAAE,WAAaA,CCdtC,IAAAG,IACCC,kBAAmB,KACnBC,aAAc,EAEdC,QAAS,WACR,GAAKL,KAAKG,mBAAqBH,KAAKI,cAAgBJ,KAAKG,kBACxD,KAAM,IAAIG,OAAO,uBAEjBN,MAAKI,gBAIPG,QAAS,WACR,GAA2B,IAAtBP,KAAKI,aACT,KAAM,IAAIE,OAAO,uBAEjBN,MAAKI,gBAIPI,SAAU,WACT,MAAOR,MAAKI,aAAe,GAG5BK,oBAAqB,SAAUC,GAC9B,GAAKV,KAAKI,aAAeM,EACxB,KAAM,IAAIJ,OAAO,qDAElBN,MAAKG,kBAAoBO,ICvBrBC,EAAgB,WACrBX,KAAKY,UAGNb,GAAEc,OAAQF,EAAcG,UAAWZ,GAClCU,OAAQ,KAERG,IAAK,SAAUC,GACThB,KAAKiB,YACTjB,KAAKY,OAAOM,KAAMF,GAElBA,KAcFG,QAAS,WACR,GAAIC,GAAQpB,KAAKY,MAEjB,KADAZ,KAAKY,UACGQ,GAASA,EAAMC,QACtBD,EAAME,WAIRC,MAAO,WACNvB,KAAKK,WAGNmB,QAAS,WACRxB,KAAKO,UACCP,KAAKiB,aACVjB,KAAKmB,WAIPF,UAAW,WACV,MAAOjB,MAAKQ,aC/Cd,IAAAiB,GAAe,GAAId,GH4GbE,EIhHSa,EAAAA,MAAMb,OJkHfc,EKlHS7B,EAAS6B,OCKlBC,EAAmB,WAAkB,IAAA,GAAAC,GAAAC,EAAAC,UAAAV,OAANW,EAAMC,MAAAH,GAAAI,EAAA,EAAAJ,EAAAI,EAAAA,IAANF,EAAME,GAAAH,UAAAG,IACzCL,EAAA7B,KAAKmC,YAAWC,KAAhBC,MAAAR,GAAqB7B,MAArBsC,OAA8BN,IAEhCjC,GAAEc,OAAOe,EAAiBd,UAAWa,GACrCC,EAAiBf,OAASA,CN0HxB,IAAI0B,IOpIJC,cAAc,GCOV/C,EAAS8C,CAEf9C,GAAOgD,WAAa3C,EAAS2C,WAAW5B,SAExCpB,EAAOS,UAAYA,EACnBT,EAAOkB,cAAgBA,EACvBlB,EAAOgC,WAAaA,EAMpBhC,EAAOiD,MAAQC,EAAQ9B,QACtBsB,WAD6B,WAE5BnC,KAAK4C,gBACL5C,KAAK6C,qBACL7C,KAAK8C,oBACL9C,KAAK+C,cACL/C,KAAKgD,cAAiBC,SASvBC,mBAAoB,SAAUC,EAAOC,EAAUC,GAC9C,GAAIC,GAAQvD,EAAEwD,SAAUH,EAASE,MAAyB7D,EAAQ2D,EAASE,OAAUtD,KAAKwD,gBAAiBJ,EAASE,MAA1EF,EAASE,IACnD,IAAKA,GAAQA,EAAKxC,oBAAqBrB,GAAOgE,SAC7C,CAAU,GAAIH,GAAMH,EAAOC,EAAUC,OAGrCK,GAAOlB,cAAmC,mBAAZmB,UAA2BA,QAAQC,KAAM,iDAAkDR,IAQ3HS,cAAe,SAAUC,GACxB9D,KAAKgD,aAAa9B,KAAM4C,IAOzBC,iBAAkB,SAAUD,GAC3B9D,KAAKgD,aAAejD,EAAEiE,QAAShE,KAAKgD,aAAcc,IAUnDG,aAAc,SAAUC,EAAeC,GACtCnE,KAAK+C,WAAW7B,MACfiD,eAAkBA,EAClBC,UAAaF,KAUfG,gBAAiB,SAAUC,GAC1BvE,EAAEwE,KAAMvE,KAAK+C,WAAY,SAAUyB,GAClC,MAAOzE,GAAE0E,OAAQD,EAAYJ,cAAiB,SAAUM,EAAkBC,GACzE,GAAIC,GAAe5E,KAAKwD,gBAAiBkB,EAEzC,OAAKJ,KAAcM,GAElBJ,EAAYL,eAAepB,WAAY4B,GAAcL,EAGrDA,EAAUO,YAAcL,EAAYL,eACpCG,EAAUQ,mBAAqBH,EAC/BL,EAAUS,uBAAyBP,EAAYL,eAAerD,UAAUkE,uBACjE,GARR,QAUEhF,MAAOqB,QACRrB,OAYJiF,mBAAoB,SAAU7B,GAC7B,GAAI8B,GAASnF,EAAEoF,IAAKnF,KAAK6C,kBAAmB,SAAUuC,GACrD,MAAOrF,GAAEsF,IAAKjC,MAAgB,SAAUkC,EAAKC,GAC5C,MAAOD,KAAQF,EAAKG,QAIhBL,GAAU9B,EAASD,OAASC,EAASE,OAC1CtD,KAAK6C,kBAAkB3B,KAAMkC,GAC7BpD,KAAKwF,aAAcpC,EAASD,MAAOC,GACnCpD,KAAKyF,iBAAkBrC,KASzBsC,kBAAmB,SAAUtC,GAC5B,GAAI8B,GAASnF,EAAEoF,IAAKnF,KAAK8C,iBAAkB,SAAUsC,GACpD,MAAOrF,GAAEsF,IAAKjC,MAAgB,SAAUkC,EAAKC,GAC5C,MAAOD,KAAQF,EAAKG,QAIhBL,GAAU9B,EAASD,OAASC,EAASE,MAC1CtD,KAAK8C,iBAAiB5B,KAAMkC,IAO9BuC,uBAAwB,WAEvB5F,EAAE6F,KAAM5F,KAAK8C,iBAAiB+C,MAAO,GAAK,SAAUT,GACnD,GAAIU,GAAerG,EAAOsG,MAAMvC,gBAAiB4B,EAAIU,aAChDA,KACJ9F,KAAKkD,mBAAoB,KAAMkC,GAC/BpF,KAAK8C,iBAAmB/C,EAAEiE,QAAShE,KAAK8C,iBAAkBsC,KAEzDpF,OASJwF,aAAc,SAAUlC,EAAMF,GACvBE,EAAKxC,UAAUkF,YACpB1C,EAAKxC,UAAUkF,cAEhB1C,EAAKxC,UAAUkF,UAAU9E,KAAMkC,GAE/BrD,EAAE6F,KAAMtC,EAAKP,eAAkB,SAAUkD,GACxCjG,KAAKwF,aAAcS,EAAU7C,IAC3BpD,OAOJyF,iBAAkB,SAAUrC,GAC3B,GAAI8C,GAAOlG,KAAKmG,cAAe/C,EAASD,OAAO,EAC/C+C,IAAQA,EAAKN,KAAM,SAAUzC,GAC5B,GAAQA,YAAiBC,GAASD,MAIlC,CAAU,GAAIC,GAASE,KAAMH,EAAOC,KAClCpD,OASJmG,cAAe,SAAU7C,EAAM8C,GACzB9C,YAAgB7D,GAAOiC,QAC3B4B,EAAOA,EAAK+C,YAIb,KADA,GAAIC,GAAYhD,EACRgD,EAAUzB,aACjByB,EAAYA,EAAUzB,WAGvB,IAAIqB,GAAOnG,EAAEwE,KAAMvE,KAAK4C,aAAc,SAAU2D,GAC/C,MAAOA,GAAKpD,QAAUmD,GAOvB,OAJMJ,IAAQE,KAAW,IACxBF,EAAOlG,KAAKwG,kBAAmBF,IAGzBJ,GAQR1C,gBAAiB,SAAUiD,GAC1B,GAAIC,GAAQD,EAAKE,MAAO,KACvBrD,EAAO,IAYR,OAVAvD,GAAEwE,KAAMvE,KAAKgD,aAAc,SAAUc,GAKpC,MAJAR,GAAOvD,EAAE6G,OAAQF,MAAa,SAAUG,EAAMvB,GAC7C,MAAOuB,GAAOA,EAAMvB,GAAQwB,QAC1BhD,GAEER,GAAQA,IAASQ,GACd,EADR,QAGE9D,MAEIsD,GAGRkD,kBAAmB,SAAUlD,GAC5B,GAAI4C,EAeJ,OAZK5C,aAAgB7D,GAAOiC,QAC3B4B,EAAOA,EAAK+C,aAIR/C,EAAKxC,oBAAqBrB,GAAOiC,QACrCwE,EAAO,GAAIzG,GAAOgD,WAClByD,EAAK/C,MAAQG,EAEbtD,KAAK4C,aAAa1B,KAAMgF,IAGlBA,GASRa,iBAAkB,SAAUzD,EAAMiD,GACjC,GAAIS,GAAKjH,EAAEwD,SAAUgD,IAAUxG,EAAEkH,SAAUV,GAASA,EAAO,IAgB3D,OAdY,QAAPS,IACCT,YAAgB9G,GAAOiC,MAC3BsF,EAAKT,EAAKS,GAEDjH,EAAEmH,SAAUX,KACrBS,EAAKT,EAAMjD,EAAKxC,UAAUqG,eAKtBH,GAAa,IAAPA,IACXA,EAAK,MAGCA,GAQRzC,KAAM,SAAUjB,EAAMiD,GACrB,GAAIS,GAAKhH,KAAK+G,iBAAkBzD,EAAMiD,GACrCL,EAAOlG,KAAKmG,cAAe7C,EAI5B,IAAK4C,EAAO,CACX,GAAIkB,GAAMlB,EAAKmB,IAAKL,EAEpB,IAAKI,YAAe9D,GACnB,MAAO8D,GAIT,MAAO,OAORE,SAAU,SAAUnE,GACnB,GAAI+C,GAAOlG,KAAKmG,cAAehD,EAE/B,IAAK+C,EAAO,CACX,GAAIqB,GAAYpE,EAAMqE,UACtBtB,GAAKnF,IAAKoC,GACVA,EAAMqE,WAAaD,IASrBE,QAAS,SAAUtE,EAAO6D,GACzB,GAAId,GAAOlG,KAAKmG,cAAehD,GAC9BuE,EAAYxB,GAAQA,EAAKmB,IAAKL,EAE/B,IAAKU,GAAavE,IAAUuE,EAK3B,KAJKjI,GAAO+C,cAAmC,mBAAZmB,UAClCA,QAAQC,KAAM,+DAAgE8D,EAAWvE,GAGpF,GAAI7C,OAAO,0FAQnBqH,OAAQ,SAAUxE,GACjB,GAAI+C,GAAOlG,KAAKmG,cAAehD,EAGzB+C,GAAK0B,SAAUzE,IACpBnD,KAAKsH,SAAUnE,GAIhB+C,EAAK2B,cAAe,UAAY1E,EAAMgE,YAAahE,EAAO+C,GAG1D/C,EAAM2E,QAAS,uBAAwB3E,EAAO+C,IAO/C6B,WAAY,SAAUzE,GACrB,GAAI4C,GACH8B,CAEI1E,aAAgBxD,GAAS4B,OAC7BwE,EAAOlG,KAAKmG,cAAe7C,GAC3B0E,GAAW1E,IAEFA,YAAgB7D,GAAOgD,YAChCyD,EAAOlG,KAAKmG,cAAe7C,EAAKH,OAChC6E,EAASjI,EAAEkI,MAAO3E,EAAK0E,UAGvB9B,EAAOlG,KAAKmG,cAAe7C,GAC3B0E,EAASjI,EAAEkI,MAAO/B,EAAK8B,SAGxBjI,EAAE6F,KAAMoC,EAAQ,SAAU7E,GACzBnD,KAAKkI,cAAe/E,GACpBpD,EAAEoI,OAAQhF,EAAMiF,eAAgB,kBAC9BpI,MAKED,EAAE6H,SAAU5H,KAAK4C,aAAcU,GACnC4C,EAAKmC,UAGLtI,EAAE6F,KAAMoC,EAAQ,SAAU7E,GACpB+C,EAAKmB,IAAKlE,GACd+C,EAAKoC,OAAQnF,GAGb+C,EAAK4B,QAAS,oBAAqB3E,EAAO+C,IAEzClG,OAQLqI,MAAO,WACNrI,KAAKkI,gBAGLnI,EAAE6F,KAAM5F,KAAK4C,aAAc,SAAUsD,GACpClG,KAAK+H,WAAY7B,IACflG,MAEHA,KAAK4C,gBACL5C,KAAK+C,cACL/C,KAAKgD,cAAiBC,WAIxBxD,EAAOsG,MAAQ,GAAItG,GAAOiD,MAkB1BjD,EAAOgE,SAAWd,EAAQ9B,OAAOX,GAAWW,QAC3CwC,SACCkF,cAAc,EACdC,eAAe,EACfC,gBAAgB,EAChBC,WAAW,EACXC,OAAO,GAGRC,SAAU,KACVrD,IAAK,KACLsD,YAAa,KACb/C,aAAc,KACdgD,kBAAmB,KACnBC,gBAAiB,KACjBC,QAAS,KAET3C,YAjBkD,SAiBtCuC,EAAUvF,EAAS4F,GA6B9B,GA5BAjJ,KAAK4I,SAAWA,EAEhBvF,EAAUtD,EAAEmH,SAAU7D,GAAYA,KAClCrD,KAAK+I,gBAAkBhJ,EAAEmJ,SAAU7F,EAAQ0F,oBAAuB/I,KAAKqD,QAAQ0F,iBAC/E/I,KAAKqD,QAAUtD,EAAEmJ,SAAU7F,EAASrD,KAAKqD,QAAS5D,EAAOgE,SAAS3C,UAAUuC,SAE5ErD,KAAK+I,gBAAgBzF,KAAQvD,EAAEwD,SAAUvD,KAAK+I,gBAAgBzF,MAC7D7D,EAAQO,KAAK+I,gBAAgBzF,OAAU7D,EAAOsG,MAAMvC,gBAAiBxD,KAAK+I,gBAAgBzF,MADpBtD,KAAK+I,gBAAgBzF,KAG5FtD,KAAKuF,IAAMvF,KAAKqD,QAAQkC,IACxBvF,KAAKmJ,UAAYnJ,KAAKqD,QAAQ8F,WAAanJ,KAAKuF,IAChDvF,KAAKoJ,eAAiBpJ,KAAKqD,QAAQ+F,gBAAkBpJ,KAAKmJ,WAAanJ,KAAKuF,IAE5EvF,KAAKmD,MAAQnD,KAAKqD,QAAQF,OAASnD,KAAK4I,SAASvC,YAEjDrG,KAAK8F,aAAe9F,KAAKqD,QAAQyC,aAE9B/F,EAAEsJ,YAAYrJ,KAAK8F,gBACrB9F,KAAK8F,aAAe9F,KAAKmD,QAGrBpD,EAAEuJ,WAAYtJ,KAAK8F,eAAqB9F,KAAK8F,aAAahF,oBAAqBrB,GAAOiC,QAC1F1B,KAAK8F,aAAe/F,EAAEwJ,OAAQvJ,KAAM,iBAEhCD,EAAEwD,SAAUvD,KAAK8F,gBACrB9F,KAAK8F,aAAerG,EAAOsG,MAAMvC,gBAAiBxD,KAAK8F,eAGlD9F,KAAKwJ,wBAKLxJ,KAAKqD,QAAQoF,gBAAkBzI,KAAK+I,gBAAgBzF,MAAQtD,KAAK+I,gBAAgBxD,KACtF7B,EAAOqC,MAAMd,mBAAoBlF,EAAEmJ,UACjCT,gBAAgB,EAChBtF,MAAOnD,KAAK8F,aACZA,aAAc9F,KAAKmD,MACnB4F,gBAAiB/I,KAAKqD,SAEvBrD,KAAK+I,kBAIFH,GAAW,CACf,GAAIa,GAAazJ,KAAKmJ,SACjBM,KAAezJ,KAAKuF,KAAOxF,EAAEmH,SAAUlH,KAAK4I,SAASvB,IAAKrH,KAAKuF,QACnEkE,EAAazJ,KAAKuF,KAGnBvF,KAAK0J,eAAgB1J,KAAK4I,SAASvB,IAAKoC,IACxCzJ,KAAK8I,kBAAoBrJ,EAAOsG,MAAMI,cAAenG,KAAK8F,cAGrD9F,KAAKmJ,YAAcnJ,KAAKuF,WACrBvF,MAAK4I,SAASe,WAAY3J,KAAKmJ,WAIvCnJ,KAAK4I,SAASgB,WAAY5J,KAAKuF,KAAQvF,KAEvCA,KAAKmC,WAAY8G,GAEZjJ,KAAKqD,QAAQqF,WACjB1I,KAAK4I,SAASiB,SAAU7J,KAAKuF,IAAKxF,EAAEmH,SAAUlH,KAAKqD,QAAQqF,WAAc1I,KAAKqD,QAAQqF,cAIvF1I,KAAK8J,SAAU9J,KAAK4I,SAAU,UAAW5I,KAAK+J,SAC5CD,SAAU9J,KAAK8I,kBAAmB,sCAAuC9I,KAAKgK,eAC9EF,SAAU9J,KAAK8I,kBAAmB,oBAAqB9I,KAAKiK,iBAQhET,mBAAoB,WACnB,GAAIU,GAAIlK,KAAK4I,SACZuB,EAAInK,KAAKuF,IACT6E,EAAIpK,KAAKmD,MACTkH,EAAKrK,KAAK8F,aACVlC,EAAOnE,EAAO+C,cAAmC,mBAAZmB,QAEtC,KAAMyG,IAAMD,IAAME,EAEjB,MADAzG,IAAQD,QAAQC,KAAM,gEAAiE5D,KAAMoK,EAAGD,EAAGE,IAC5F,CAGR,MAAQD,EAAEtJ,oBAAqBrB,GAAOiC,OAErC,MADAkC,IAAQD,QAAQC,KAAM,2EAA4E5D,KAAMkK,IACjG,CAGR,MAAQG,EAAGvJ,oBAAqBrB,GAAOiC,OAEtC,MADAkC,IAAQD,QAAQC,KAAM,kFAAmF5D,KAAMqK,IACxG,CAGR,IAAKrK,eAAgBP,GAAO6K,SAAWtK,KAAK+I,gBAAgBzF,OAAS7D,EAAO6K,QAE3E,MADA1G,IAAQD,QAAQC,KAAM,kFAAmF5D,OAClG,CAGR,IAAKkK,GAAKnK,EAAEwK,KAAML,EAAEN,YAAavI,OAAS,CACzC,GAAImJ,GAAWzK,EAAEwE,KAAM2F,EAAEN,WAAY,SAAUxE,GAC9C,MAAOA,GAAIG,MAAQ4E,GACjBnK,KAEH,IAAKwK,EAGJ,MAFA5G,IAAQD,QAAQC,KAAM,8EACrB5D,KAAMmK,EAAGD,EAAGM,IACN,EAIT,OAAO,GAORC,WAAY,SAAUzB,GACrBhJ,KAAKgJ,QAAUA,EACfhJ,KAAK4I,SAASe,WAAY3J,KAAKuF,KAAQyD,GASxC0B,mBAAoB,SAAUtH,GAC7B,MAAOA,GAASwF,mBAAoB5I,MAAK8F,cAAgB9F,KAAK+I,gBAAgBxD,MAAQnC,EAASmC,KAC9FvF,KAAKuF,MAAQnC,EAAS2F,gBAAgBxD,KASxCoF,oBAAqB,SAAUxH,GAO9B,IAAK,GANDyH,MAEA5C,EAAUjI,EAAEsJ,YAAalG,GAAsBnD,KAAKgJ,UAAahJ,KAAKgJ,QAAQhB,SAAYhI,KAAKgJ,WAA1D7F,GACxC6C,EAAY,KACZ5C,EAAW,KAEH8G,EAAI,EAAGA,GAAMlC,OAAe3G,OAAQ6I,IAAM,CAClDlE,EAAYgC,EAAQkC,GAAI9B,kBAExB,KAAK,GAAIyC,GAAI,EAAGA,EAAI7E,EAAU3E,OAAQwJ,IACrCzH,EAAW4C,EAAW6E,GAGjB7K,KAAK0K,mBAAoBtH,IAC7BwH,EAAiB1J,KAAMkC,GAK1B,MAAOwH,IAORb,QAAS,WACR/J,KAAKkI,gBAEAlI,eAAgBP,GAAOqL,OAC3B9K,KAAKyK,WAAY,MAERzK,eAAgBP,GAAO6K,SAChCtK,KAAKyK,WAAYzK,KAAK+K,sBAGvBhL,EAAE6F,KAAM5F,KAAK2K,sBAAuB,SAAUvH,GAC7CA,EAAS6G,cAAejK,KAAK4I,WAC3B5I,SAILP,EAAOqL,OAASrL,EAAOgE,SAAS5C,QAC/BwC,SACC0F,iBAAmBzF,KAAM,YAG1BnB,WAAY,SAAU8G,GACrBjJ,KAAK8J,SAAU9J,KAAK4I,SAAU,qBAAuB5I,KAAKuF,IAAKvF,KAAKgL,SAEpE,IAAIhC,GAAUhJ,KAAKiL,YAAahC,EAChCjJ,MAAKyK,WAAYzB,GAGjBjJ,EAAE6F,KAAM5F,KAAK2K,sBAAuB,SAAUvH,GAC7CA,EAAS8H,WAAYlL,KAAK4I,SAAUK,IAClCjJ,OAQJiL,YAAa,SAAU5H,GACtB,GAAI2F,GAAU,IAId,IAFA3F,EAAUtD,EAAEmJ,UAAYP,MAAO3I,KAAKqD,QAAQsF,OAAStF,GAEhDrD,KAAK6I,sBAAuB7I,MAAK8F,aACrCkD,EAAUhJ,KAAK6I,gBAEX,IAAK7I,KAAK6I,aAAoC,IAArB7I,KAAK6I,YAAoB,CACtD,GAAII,GAAOlJ,EAAEmJ,UAAY9C,OAAQpG,KAAKqD,QAAQkF,cAAgBlF,EAC9D2F,GAAUhJ,KAAK8F,aAAaqF,aAAcnL,KAAK6I,YAAaI,GAQ7D,MAJKD,KACJhJ,KAAKoL,MAAQ,MAGPpC,GAORU,eAAgB,SAAUb,GACzB7I,KAAK6I,YAAcA,EACnB7I,KAAKoL,MAAQ3L,EAAOsG,MAAMgB,iBAAkB/G,KAAK8F,aAAc9F,KAAK6I,cAOrEmC,SAAU,SAAU7H,EAAOkI,EAAMhI,GAEhC,IAAKrD,KAAKQ,WAAV,CAGAR,KAAKK,UACLgD,EAAUA,EAAUtD,EAAEkI,MAAO5E,KAK7B,IAAIiI,GAAUvL,EAAEsJ,YAAahG,EAAQkI,WACpCC,EAAaF,EAAUtL,KAAKgJ,QAAU3F,EAAQkI,SAE/C,IAAKD,EAAU,CACdtL,KAAK0J,eAAgB2B,EACrB,IAAIrC,GAAUhJ,KAAKiL,YAAa5H,EAChCrD,MAAKyK,WAAYzB,GAkBlB,GAdKwC,GAAcxL,KAAKgJ,UAAYwC,GACnCzL,EAAE6F,KAAM5F,KAAK2K,oBAAqBa,GAAc,SAAUpI,GACzDA,EAAS6G,cAAejK,KAAK4I,SAAU,KAAMvF,IAC3CrD,MAMJD,EAAE6F,KAAM5F,KAAK2K,sBAAuB,SAAUvH,GAC7CA,EAAS8H,WAAYlL,KAAK4I,SAAUvF,IAClCrD,OAGGqD,EAAQoI,QAAUzL,KAAKgJ,UAAYwC,EAAa,CACrD,GAAIE,GAAM1L,IACVA,MAAKsL,SAAU,EACf5H,EAAOjC,WAAWV,IAAK,WACtB2K,EAAI9C,SAASd,QAAS,UAAY4D,EAAInG,IAAKmG,EAAI9C,SAAU8C,EAAI1C,QAAS3F,GAAS,GAC/EqI,EAAIJ,SAAU,IAGhBtL,KAAKO,YAMNyJ,cAAe,SAAU7G,EAAO+C,EAAM7C,IAC9BrD,KAAKoL,OAAwB,IAAfpL,KAAKoL,OAAiBjI,EAAM6D,KAAOhH,KAAKoL,QAC5DpL,KAAKkL,WAAY/H,EAAOE,GACxBrD,KAAKoL,MAAQ,OAIfF,WAAY,SAAU/H,EAAOE,GAG5B,GAAIqI,GAAM1L,IACVmD,GAAM/B,MAAO,WACZ,GAAK+B,IAAUuI,EAAI1C,QAAU,CAC5B,GAAIwC,GAAaE,EAAI1C,SAAW,IAChC0C,GAAIjB,WAAYtH,GAChBuI,EAAIV,SAAUU,EAAI9C,SAAUzF,EAAOpD,EAAEmJ,UAAYqC,UAAWC,GAAcnI,QAK7E4G,cAAe,SAAU9G,EAAO+C,EAAM7C,GACrC,GAAMrD,KAAKgJ,SAIN7F,IAAUnD,KAAKgJ,QAAU,CAC7B,GAAIwC,GAAaxL,KAAKgJ,SAAW,IACjChJ,MAAKyK,WAAY,MACjBzK,KAAKgL,SAAUhL,KAAK4I,SAAUzF,EAAOpD,EAAEmJ,UAAYqC,UAAWC,GAAcnI,QAK/E5D,EAAO6K,QAAU7K,EAAOgE,SAAS5C,QAChC8K,eAAgB,KAEhBtI,SACC0F,iBAAmBzF,KAAM,UACzBqI,eAAgBlM,EAAOgD,WACvBmJ,eAAe,EACfC,sBAGD1J,WAAY,SAAU8G,GAWrB,GAVAjJ,KAAK8J,SAAU9J,KAAK4I,SAAU,qBAAuB5I,KAAKuF,IAAKvF,KAAKgL,UAGpEhL,KAAK2L,eAAiB3L,KAAKqD,QAAQsI,gBAC9B5L,EAAEuJ,WAAYtJ,KAAK2L,iBAAoB3L,KAAK2L,iBAAmBlM,EAAOgD,YAAiBzC,KAAK2L,eAAe7K,oBAAqBrB,GAAOgD,aAC3IzC,KAAK2L,eAAiB5L,EAAEwJ,OAAQvJ,KAAM,mBAElCD,EAAEwD,SAAUvD,KAAK2L,kBACrB3L,KAAK2L,eAAiBlM,EAAOsG,MAAMvC,gBAAiBxD,KAAK2L,iBAErD3L,KAAK2L,iBAAmBlM,EAAOgD,cAAiBzC,KAAK2L,eAAe7K,oBAAqBrB,GAAOgD,YACpG,KAAM,IAAInC,OAAO,uDAGlB,IAAI0I,GAAUhJ,KAAKiL,YAAahC,EAChCjJ,MAAKyK,WAAYzB,IASlB+B,mBAAoB,SAAUvD,GAK7B,GAJKxH,KAAKgJ,SACThJ,KAAKkI,cAAelI,KAAKgJ,WAGpBxB,GAAiBA,YAAsB/H,GAAOgD,YAAe,CAClE,GAAIY,GAAUtD,EAAEuJ,WAAYtJ,KAAKqD,QAAQwI,mBACxC7L,KAAKqD,QAAQwI,kBAAmB7L,KAAK4I,UAAa5I,KAAKqD,QAAQwI,iBAEhErE,GAAa,GAAIxH,MAAK2L,eAAgB,KAAMtI,GAK7C,GAFAmE,EAAWrE,MAAQnD,KAAK8F,aAEnB9F,KAAKqD,QAAQuI,cAAgB,CACjC,GAAIrG,GAAMvF,KAAKqD,QAAQuI,iBAAkB,EAAO5L,KAAKqD,QAAQ0F,gBAAgBxD,IAAMvF,KAAKqD,QAAQuI,aAE3FpE,GAAYjC,IAASiC,EAAYjC,KAAUvF,KAAK4I,SAC/CnJ,EAAO+C,cAAmC,mBAAZmB,UAClCA,QAAQC,KAAM,gEAAiE5D,KAAMuF,EAAKvF,KAAKqD,QAAQuI,eAG/FrG,IACTiC,EAAYjC,GAAQvF,KAAK4I,UAQ3B,MAJA5I,MAAK8J,SAAUtC,EAAY,iBAAkBxH,KAAK8L,gBAChDhC,SAAUtC,EAAY,oBAAqBxH,KAAK+L,eAChDjC,SAAUtC,EAAY,mBAAoBxH,KAAKgM,aAE1CxE,GAQRyD,YAAa,SAAU5H,GACtB,GAAI2F,GAAU,IAKd,IAHA3F,EAAUtD,EAAEmJ,UAAYP,MAAO3I,KAAKqD,QAAQsF,OAAStF,GAGhDrD,KAAK6I,sBAAuBpJ,GAAOgD,WACvCzC,KAAK+K,mBAAoB/K,KAAK6I,aAC9BG,EAAUhJ,KAAK6I,gBAIX,CACJ,GAAIoD,KAEJlM,GAAE6F,KAAM5F,KAAK6I,YAAa,SAAUc,GACnC,GAAIxG,GAAQ,IAGXA,GADIwG,YAAsB3J,MAAK8F,aACvB6D,EAIE5J,EAAEmH,SAAUyC,IAAgBtG,EAAQsF,OAAS3I,KAAK8F,aAAahF,UAAU6H,MAClF3I,KAAK8F,aAAahF,UAAU6H,MAAO5I,EAAEkI,MAAO0B,GAActG,GAAYsG,EAGxExG,GAAS8I,EAAM/K,KAAMiC,IACnBnD,MAGFgJ,EADIhJ,KAAKgJ,kBAAmBvJ,GAAOgD,WACzBzC,KAAKgJ,QAGLhJ,KAAK+K,qBAKhB/B,EAAQkD,IAAKD,EAAOlM,EAAEmJ,UAAYP,OAAO,GAAStF,IAMnD,MAFArD,MAAKmM,OAASpM,EAAEqM,WAAYpM,KAAKmM,OAAQpM,EAAEsM,MAAOrD,EAAQhB,OAAQ,OAE3DgB,GAORU,eAAgB,SAAUb,GACzB7I,KAAK6I,YAAcA,YAAuBpJ,GAAOgD,WAAaoG,EAAc,KAC5E7I,KAAKmM,UAECnM,KAAK6I,cAAiBA,GAA+B,IAAhBA,IAE1C7I,KAAK6I,YAAc9I,EAAEuM,QAASzD,GAAgBA,GAAgBA,GAE9D9I,EAAE6F,KAAM5F,KAAK6I,YAAa,SAAUtC,GACnC,GAAIgG,GAAS9M,EAAOsG,MAAMgB,iBAAkB/G,KAAK8F,aAAcS,IAC1DgG,GAAqB,IAAXA,IACdvM,KAAKmM,OAAOjL,KAAMqL,IAEjBvM,QAQLgL,SAAU,SAAU7H,EAAOkI,EAAMhI,GAChCA,EAAUA,EAAUtD,EAAEkI,MAAO5E,MAC7BrD,KAAK0J,eAAgB2B,GACrBrL,KAAKsL,SAAU,CAEf,IAAItC,GAAUhJ,KAAKiL,YAAa5H,EAGhC,IAFArD,KAAKyK,WAAYzB,IAEX3F,EAAQoI,OAAS,CACtB,GAAIC,GAAM1L,IACV0D,GAAOjC,WAAWV,IAAK,WAEjB2K,EAAIJ,UACRI,EAAI9C,SAASd,QAAS,UAAY4D,EAAInG,IAAKmG,EAAI9C,SAAU8C,EAAI1C,QAAS3F,GAAS,GAC/EqI,EAAIJ,SAAU,OAUlBQ,eAAgB,SAAU3I,EAAO+C,EAAM7C,GAEtCA,EAAUA,EAAUtD,EAAEkI,MAAO5E,MAC7BrD,KAAKsL,SAAU,EAEfvL,EAAE6F,KAAM5F,KAAK2K,oBAAqBxH,GAAS,SAAUC,GACpDA,EAAS8H,WAAYlL,KAAK4I,SAAUvF,IAClCrD,KAGH,IAAI0L,GAAM1L,MACTqD,EAAQoI,QAAUhM,EAAOgC,WAAWV,IAAK,WACzC2K,EAAI9C,SAASd,QAAS,OAAS4D,EAAInG,IAAKpC,EAAOuI,EAAI1C,QAAS3F,MAQ9D0I,cAAe,SAAU5I,EAAO+C,EAAM7C,GAErCA,EAAUA,EAAUtD,EAAEkI,MAAO5E,MAC7BrD,KAAKsL,SAAU,EAEfvL,EAAE6F,KAAM5F,KAAK2K,oBAAqBxH,GAAS,SAAUC,GACpDA,EAAS6G,cAAejK,KAAK4I,SAAU,KAAMvF,IAC3CrD,KAEH,IAAI0L,GAAM1L,MACTqD,EAAQoI,QAAUhM,EAAOgC,WAAWV,IAAK,WACzC2K,EAAI9C,SAASd,QAAS,UAAY4D,EAAInG,IAAKpC,EAAOuI,EAAI1C,QAAS3F,MAIjE2I,YAAa,SAAU9F,EAAM7C,GAC5B,GAAIqI,GAAM1L,IACVqD,GAAUA,EAAUtD,EAAEkI,MAAO5E,OAC5BA,EAAQoI,QAAUhM,EAAOgC,WAAWV,IAAK,WACzC2K,EAAI9C,SAASd,QAAS,SAAW4D,EAAInG,IAAKmG,EAAI1C,QAAS3F,MAIzD2G,cAAe,SAAU7G,EAAO+C,EAAM7C,GACrC,GAAIkD,GAAOxG,EAAE6H,SAAU5H,KAAKmM,OAAQhJ,EAAM6D,GAErCT,KACJvG,KAAKkL,WAAY/H,EAAOE,GACxBrD,KAAKmM,OAASpM,EAAEiE,QAAShE,KAAKmM,OAAQhJ,EAAM6D,MAI9CkE,WAAY,SAAU/H,EAAOE,GAG5B,GAAIqI,GAAM1L,IACVmD,GAAM/B,MAAO,WACPsK,EAAI1C,UAAY0C,EAAI1C,QAAQ3B,IAAKlE,IACrCuI,EAAI1C,QAAQjI,IAAKoC,EAAOpD,EAAEmJ,UAAYP,OAAO,GAAStF,OAKzD4G,cAAe,SAAU9G,EAAO+C,EAAM7C,GAChCrD,KAAKgJ,QAAQ3B,IAAKlE,IACtBnD,KAAKgJ,QAAQV,OAAQnF,EAAOE,MAY/B5D,EAAOiC,MAAQ5B,EAAS4B,MAAMb,OAAOX,GAAWW,QAC/CmF,UAAW,KACX4D,WAAY,KACZ4C,gBAAgB,EAChBC,kBAAkB,EAClB7L,OAAQ,KACR8L,uBAAuB,EAEvB1H,sBAAuB,OACvBd,cAAe,KAEfmC,YAAa,SAAUsD,EAAYtG,GAKlC,GAAKA,GAAWA,EAAQmE,WAAa,CACpC,GAAIkE,GAAM1L,KACTwH,EAAaxH,KAAKwH,WAAanE,EAAQmE,iBAGjCnE,GAAQmE,WAEfxH,KAAKyM,kBAAmB,CAExB,IAAIE,GAAe,QAAfA,GAAyBxJ,GACvBA,IAAUuI,IACdA,EAAIe,kBAAmB,EACvBf,EAAIiB,eACJnF,EAAWoF,IAAK,iBAAkBD,IAGpCnF,GAAWqF,GAAI,iBAAkBF,GAGjC5M,EAAE+M,MAAO,WACRH,EAAcjB,KAIhBhI,EAAOqC,MAAMJ,yBACbjC,EAAOqC,MAAM+D,SAAU9J,KAAM,wBAAyBP,EAAOsG,MAAMgC,YAEnE/H,KAAKY,OAAS,GAAInB,GAAOkB,cACzBX,KAAKY,OAAOW,QACZmC,EAAOjC,WAAWF,OAElB,KACCtB,EAASyB,MAAMW,MAAOrC,KAAM+B,WAD7B,QAKC2B,EAAOjC,WAAWD,YAOpBsG,QAAS,SAAUiF,GAClB,GAAKA,EAAU1L,OAAS,GAAuC,IAAlC0L,EAAUC,QAAS,UAAmB,CAClE,GAAItB,GAAM1L,KACTgC,EAAOD,SAEFtC,GAAOgC,WAAWjB,WAKvBkD,EAAOjC,WAAWV,IAAK,WAEtB,GAAIuK,IAAU,CACd,IAAmB,WAAdyB,EAEJzB,EAAUI,EAAIuB,cAAgBvB,EAAIgB,sBAClChB,EAAIgB,uBAAwB,MAExB,CACJ,GAAIrB,GAAO0B,EAAUlH,MAAO,GAC3BT,EAAMsG,EAAIwB,YAAa7B,EAEnBjG,IAKJkG,EAAYtJ,EAAM,MAAQ,EAIrBsJ,EACJI,EAAIJ,QAASD,GAASrJ,EAAM,GAIlBoD,EAAIkG,eACPI,GAAIJ,QAASD,IAGZC,IACTI,EAAIgB,uBAAwB,GAI9BpB,GAAWxL,EAAS4B,MAAMZ,UAAUgH,QAAQzF,MAAOqJ,EAAK1J,KAtCzD/B,EAASyB,MAAMZ,UAAUgH,QAAQzF,MAAOqJ,EAAK1J,OA0CvB,YAAd+K,GACT9M,EAASyB,MAAMZ,UAAUgH,QAAQzF,MAAOrC,KAAM+B,WAC9C2B,EAAOqC,MAAMgC,WAAY/H,OAGzBC,EAASyB,MAAMZ,UAAUgH,QAAQzF,MAAOrC,KAAM+B,UAG/C,OAAO/B,OAORmN,oBAAqB,SAAU9J,GAC9BrD,KAAKK,UACLL,KAAK4J,cAEL7J,EAAE6F,KAAM5F,KAAKgG,cAAiB,SAAUZ,GACvC1B,EAAOqC,MAAM7C,mBAAoBlD,KAAMoF,EAAK/B,IAC1CrD,MAEHA,KAAKwM,gBAAiB,EACtBxM,KAAKO,UACLP,KAAK2M,gBASNS,gBAAiB,SAAUC,EAAchK,GACnCrD,KAAKwM,iBAAmBxM,KAAKQ,YACjCT,EAAE6F,KAAM5F,KAAK4J,WAAY,SAAUxE,GAClC,IAAMiI,GAAkBjI,EAAI+D,YAAakE,IAAgBjI,EAAIG,MAAO8H,GAAiB,CAEpF,GAAIC,GAAQtN,KAAK2J,WAAYvE,EAAI+D,YAAenJ,KAAK2J,WAAYvE,EAAIG,KACpE8F,EAAOgC,IAAkBA,EAAcjI,EAAI+D,YAAekE,EAAcjI,EAAIG,OAIxEH,EAAI4D,UAAYsE,GAAqB,OAAVA,GAA2B,OAATjC,IACjDrL,KAAK8H,QAAS,qBAAuB1C,EAAIG,IAAKvF,KAAMsN,EAAOjK,OAKxD+B,EAAI+D,YAAc/D,EAAIG,WACnBvF,MAAK2J,WAAYvE,EAAI+D,YAE3BnJ,OAOLoB,MAAO,SAAUJ,GAChBhB,KAAKY,OAAOG,IAAKC,IAMlB2L,aAAc,WACR3M,KAAKwM,iBAAmBxM,KAAKyM,kBAAoBzM,KAAKY,OAAOK,aACjEjB,KAAKY,OAAOY,WASd0L,YAAa,SAAU7B,GACtB,MAAOrL,MAAK4J,WAAYyB,IAOzBjD,aAAc,WACb,MAAOrI,GAAEwN,OAAQvN,KAAK4J,aAUvB4D,cAAe,SAAUnC,EAAMoC,GAC9B,GAAIrI,GAAMiG,YAAgB5L,GAAOgE,SAAW4H,EAAOrL,KAAKkN,YAAa7B,GACpEqC,EAAMtI,EAAQA,EAAI+G,QAAU/G,EAAI+G,OAAOtG,MAAO,KAAaT,EAAIgG,OAAuB,IAAdhG,EAAIgG,OAAkBhG,EAAIgG,aAGnG,IAAKqC,EAAU,CACd,GAAIzF,GAAS5C,EAAI4D,UAAa5D,EAAI4D,QAAQhB,SAAY5C,EAAI4D,SAC1DjJ,GAAE6F,KAAMoC,EAAQ,SAAU7E,IACpBA,EAAM6D,IAAmB,IAAb7D,EAAM6D,KACtB0G,EAAIxM,KAAMiC,EAAM6D,MAKnB,MAAO0G,IAYR7D,SAAU,SAAUwB,EAAMhI,GAEzBA,EAAUtD,EAAEc,QAAUE,KAAK,EAAMuH,QAAQ,EAAOmF,SAAS,GAASpK,EAElE,IAAIqI,GAAM1L,KACT2N,KACAvI,EAAMpF,KAAKkN,YAAa7B,GACxBuC,EAAaxI,GAAOpF,KAAKwN,cAAepI,EAAK/B,EAAQoK,SACrDvH,EAAOd,EAAI4D,kBAAmBvJ,GAAOgD,WAAa2C,EAAI4D,QAAU5D,EAAI0D,iBAErE,IAAK8E,GAAcA,EAAWvM,OAAS,CACtC,GAECwM,GAFG7F,KACH8F,KAEAvF,EAAe,WAEdP,EAASjI,EAAEgO,IAAKH,EAAY,SAAU5G,GACrC,GAAI7D,GAAQiC,EAAIU,aAAakI,UAAWhH,EAExC,KAAM7D,EAAQ,CACb,GAAI8K,KACJA,GAAO7I,EAAIU,aAAahF,UAAUqG,aAAgBH,EAClD7D,EAAQiC,EAAIU,aAAaqF,aAAc8C,EAAO5K,GAC9CyK,EAAc5M,KAAMiC,GAGrB,MAAOA,IACLnD,MAOL,IAAKkG,YAAgBzG,GAAOgD,YAAc1C,EAAEuJ,WAAYpD,EAAKgI,KAAQ,CACpE,GAAIC,GAAajI,EAAKgI,KACtBL,GAAS3H,EAAKgI,IAAKN,GAEdC,IAAWM,IACf5F,IACAsF,EAAS3H,EAAKgI,IAAKlG,GAEd6F,IAAWM,IACfN,EAAS,OAKZ,GAAKA,EAAS,CAEb,GAAI5E,GAAOlJ,EAAEmJ,UAEXkF,MAAO,WACNrO,EAAE6F,KAAMkI,EAAe,SAAU3K,GAChCA,EAAM2E,QAAS,UAAW3E,EAAOA,EAAMqE,WAAYnE,KAGpDA,EAAQ+K,OAAS/K,EAAQ+K,MAAM/L,MAAO2F,EAAQjG,YAE/CmM,IAAKL,GAENxK,EAGDsK,IAAazH,EAAKmI,MAAOpF,QAIlBjB,GAAO3G,QACbkH,IAGDoF,EAAW5N,EAAEgO,IAAK/F,EAAQ,SAAU7E,GACnC,GAAI8F,GAAOlJ,EAAEmJ,UAEXkF,MAAO,WACDrO,EAAE6H,SAAUkG,EAAe3K,IAC/BA,EAAM2E,QAAS,UAAW3E,EAAOA,EAAMqE,WAAYnE,GAEpDA,EAAQ+K,OAAS/K,EAAQ+K,MAAM/L,MAAO2F,EAAQjG,aAGhDsB,EAED,OAAOF,GAAMkL,MAAOpF,IAClBjJ,MAIL,MAAOA,MAAKsO,WAAWX,GAAUY,KAChC,WACC,MAAOzO,GAAS4B,MAAMZ,UAAUuG,IAAIjF,KAAMsJ,EAAKL,MAKlDiD,WAAY,SAASE,GACpB,MAAO1O,GAAS2O,EAAEC,KAAKrM,MAAM,KAAMmM,IAGpCtC,IAAK,SAAU3G,EAAK+H,EAAOjK,GAC1BK,EAAOjC,WAAWF,OAGlB,IAAIoI,GACHJ,CAEIxJ,GAAEmH,SAAU3B,IAAgB,MAAPA,GACzBoE,EAAapE,EACblC,EAAUiK,IAGV3D,KACAA,EAAYpE,GAAQ+H,EAGrB,KACC,GAAItG,GAAKhH,KAAKgH,GACb2H,EAAQhF,GAAc3J,KAAKmH,cAAewC,IAAcA,EAAY3J,KAAKmH,YAG1EzD,GAAOqC,MAAM0B,QAASzH,KAAM2O,GAE5BpF,EAASzJ,EAAS4B,MAAMZ,UAAUoL,IAAI7J,MAAOrC,KAAM+B,WAG7C/B,KAAKwM,gBAAmBxM,KAAKQ,WAWzBmO,GAASA,IAAU3H,GAC5BtD,EAAOqC,MAAM4B,OAAQ3H,OAXrBA,KAAKqG,YAAYuI,4BAGZD,GAAmB,IAAVA,IACbjL,EAAOqC,MAAMuB,SAAUtH,MAGxBA,KAAKmN,oBAAqB9J,IAOtBsG,GACJ3J,KAAKoN,gBAAiBzD,EAAYtG,GA1BpC,QA+BCK,EAAOjC,WAAWD,UAGnB,MAAO+H,IAGRtB,MAAO,WACN,GAAI0B,GAAa5J,EAAEkI,MAAOjI,KAAK2J,WAS/B,OARM5J,GAAEsJ,YAAaM,EAAY3J,KAAKmH,gBACrCwC,EAAY3J,KAAKmH,aAAgB,MAGlCpH,EAAE6F,KAAM5F,KAAKoI,eAAgB,SAAUhD,SAC/BuE,GAAYvE,EAAIG,OAGjB,GAAIvF,MAAKqG,YAAasD,IAM9BkF,OAAQ,SAAUxL,GAEjB,GAAKrD,KAAKQ,WACT,MAAOR,MAAKgH,EAGbhH,MAAKK,SACL,IAAIyO,GAAOhP,EAAS4B,MAAMZ,UAAU+N,OAAOzM,KAAMpC,KAAMqD,EA6EvD,QA3EKrD,KAAKqG,YAAYxB,aAAkB7E,KAAKqG,YAAYtB,yBAA0B+J,KAClFA,EAAM9O,KAAKqG,YAAYtB,wBAA2B/E,KAAKqG,YAAYvB,oBAGpE/E,EAAE6F,KAAM5F,KAAK4J,WAAY,SAAUxE,GAClC,GAAI4D,GAAU8F,EAAM1J,EAAIG,KACvBiD,EAAgBpD,EAAI/B,QAAQmF,cAC5B8E,EAAQ,IAEJ9E,MAAkB,EACjBQ,GAAWjJ,EAAEuJ,WAAYN,EAAQ6F,UACrCvB,EAAQtE,EAAQ6F,OAAQxL,IAGhBtD,EAAEwD,SAAUiF,IAChBQ,YAAmBvJ,GAAOgD,WAC9B6K,EAAQtE,EAAQqD,MAAO7D,GAEdQ,YAAmBlJ,GAAS4B,QACrC4L,EAAQtE,EAAQ3B,IAAKmB,IAIjBA,IAAkBpD,EAAIU,aAAahF,UAAUqG,cAC5C/B,YAAe3F,GAAO6K,QAC1BgD,EAAQA,EAAMhL,OAAQ8C,EAAI+G,QAEjB/G,YAAe3F,GAAOqL,SAC/BwC,EAAQA,GAASlI,EAAIgG,MAEfkC,GAAUvN,EAAEmH,SAAU9B,EAAIyD,eAC/ByE,EAAQlI,EAAIyD,aAAe,SAKrB9I,EAAEuM,QAAS9D,GACfQ,YAAmBvJ,GAAOgD,YAC9B6K,KACAtE,EAAQpD,KAAM,SAAUzC,GACvB,GAAI4L,KACJhP,GAAE6F,KAAM4C,EAAe,SAAUjD,GAChCwJ,EAASxJ,GAAQpC,EAAMkE,IAAK9B,KAE7B+H,EAAMpM,KAAM6N,MAGJ/F,YAAmBlJ,GAAS4B,QACrC4L,KACAvN,EAAE6F,KAAM4C,EAAe,SAAUjD,GAChC+H,EAAO/H,GAAQyD,EAAQ3B,IAAK9B,YAKvBuJ,GAAM1J,EAAIG,KAMH,OAAV+H,GAAkBjK,GAAWA,EAAQ2L,OACzC1B,EAAQtE,GAGJR,IACJsG,EAAM1J,EAAIgE,gBAAmBkE,GAGzBlI,EAAIgE,iBAAmBhE,EAAIG,WACxBuJ,GAAM1J,EAAIG,OAInBvF,KAAKO,UACEuO,KASRG,MAAO,SAAUC,GAgDhB,MA7CAlP,MAAKc,UAAUkF,WAAchG,KAAKc,UAAUkF,eAAkBH,MAAO,GAErE7F,KAAK+C,cACL/C,KAAK6E,YAAc,KAGd7E,KAAKc,UAAUqO,eAAgB,iBACnCzL,EAAOqC,MAAM9B,aAAcjE,KAAKc,UAAUoD,cAAelE,MAIzDA,KAAKc,UAAUoD,cAAgB,KAIhCnE,EAAE6F,KAAM5F,KAAKc,UAAUkF,cAAiB,SAAUZ,GAKjD,GAJMA,EAAIjC,QACTiC,EAAIjC,MAAQnD,MAGRoF,EAAI2D,iBAAmB3D,EAAIjC,QAAUnD,KAAO,CAChD,GAAIoP,IAAgB,CACpB,IAAKrP,EAAEwD,SAAU6B,EAAIU,cAAiB,CAUrC,GAAIA,GAAerG,EAAOsG,MAAMvC,gBAAiB4B,EAAIU,aACrDsJ,GAAgBtJ,GAAkBA,EAAahF,oBAAqBrB,GAAOiC,MAGvE0N,EACJ1L,EAAOqC,MAAM7C,mBAAoB,KAAMkC,GAE9BrF,EAAEwD,SAAU6B,EAAIU,eACzBpC,EAAOqC,MAAML,kBAAmBN,KAGhCpF,MAEIA,MASRqP,MAAO,SAAU1F,EAAYtG,GAE5BrD,KAAK4O,0BAGL,IAAIzL,GAAQnD,KAAKsP,kBAAmBtP,KAAM2J,IAAgB3J,IAE1D,OAAO,IAAImD,GAAOwG,EAAYtG,IAY/BiM,kBAAmB,SAAUhM,EAAMqG,GAClC,GAAKrG,EAAKP,YAAcO,EAAKxC,UAAUkE,wBAAyB2E,GAAa,CAC5E,GAAI3E,GAAwB2E,EAAYrG,EAAKxC,UAAUkE,uBACnDJ,EAAetB,EAAKP,WAAYiC,EACpC,IAAKJ,EACJ,MAAOA,EAIP,KAAMI,IAAyB1B,GAAKP,WAEnC,GADA6B,EAAe5E,KAAKsP,kBAAmBhM,EAAKP,WAAYiC,GAAyB2E,GAEhF,MAAO/E,GAKX,MAAO,OAMRgK,yBAA0B,WAMzB,GAJA5O,KAAKuP,mBAIAvP,KAAKc,UAAUoD,cAAgB,CACnC,GAAIsL,GAAoBzP,EAAEwK,KAAMvK,KAAK+C,YACjC0M,EAAsB1P,EAAE2P,KAAM1P,KAAKc,UAAUoD,cAAesL,EAChEzP,GAAE6F,KAAM6J,EAAqB,SAAU/K,GACtC,GAAIE,GAAenF,EAAOsG,MAAMvC,gBAAiBkB,EACjDE,IAAgBA,EAAagK,+BAKhCW,iBAAkB,WAEjB,GAAMxP,EAAEsJ,YAAarJ,KAAK6E,cAAkB9E,EAAE4P,OAAQ3P,KAAK6E,aAQ3D,GAJAnB,EAAOqC,MAAM1B,gBAAiBrE,MAIzBA,KAAK6E,aAKT,GADA7E,KAAK6E,YAAY0K,mBACZvP,KAAK6E,YAAY/D,UAAUkF,UAAY,CAE3C,GAAI4J,GAAqB7P,EAAE0E,OAAQzE,KAAK6E,YAAY/D,UAAUkF,cAAiB,SAAU6J,GACxF,OAAQ9P,EAAEoF,IAAKnF,KAAKc,UAAUkF,cAAiB,SAAUZ,GACxD,MAAOyK,GAAS/J,eAAiBV,EAAIU,cAAgB+J,EAAStK,MAAQH,EAAIG,KACxEvF,OACDA,KAEHA,MAAKc,UAAUkF,UAAY4J,EAAmBtN,OAAQtC,KAAKc,UAAUkF,gBAMtEhG,MAAK6E,aAAc,GAgBrBsG,aAAc,SAAUxB,EAAYtG,GACnCA,IAAaA,KACb,IAAIyM,GAAqB/P,EAAEmH,SAAUyC,IAAgBtG,EAAQsF,OAAS3I,KAAKc,UAAU6H,MACpF3I,KAAKc,UAAU6H,MAAO5I,EAAEkI,MAAO0B,GAActG,GAAYsG,EAItDxG,EAAQnD,KAAKgO,UAAW8B,EAiB5B,OAbK/P,GAAEmH,SAAUyC,KACXxG,GAASE,EAAQ0M,SAAU,SAExB1M,GAAQmE,iBACRnE,GAAQ6K,IAEf/K,EAAM+I,IAAK4D,EAAkBzM,IAEnBF,GAASE,EAAQ+C,UAAW,IACtCjD,EAAQnD,KAAKqP,MAAOS,EAAkB/P,EAAEmJ,UAAYP,OAAO,GAAStF,MAI/DF,GAaRoB,KAAM,SAAUoF,EAAYtG,GAG3B,MAFAA,KAAaA,MACbA,EAAQ+C,QAAS,EACVpG,KAAKmL,aAAcxB,EAAYtG,IASvC2K,UAAW,SAAUrE,GACpB,MAAOlK,GAAOsG,MAAMxB,KAAMvE,KAAM2J,MAUlClK,EAAOgD,WAAW3B,UAAUkP,eAAiBvQ,EAAOgD,WAAW3B,UAAUmP,cACzExQ,EAAOgD,WAAW3B,UAAUmP,cAAgB,SAAUhC,EAAO5K,GAC5D,GAAIF,EAyBJ,OAvBK8K,aAAiBnO,GAAS4B,OACxBuM,EAAMzG,aACXyG,EAAMzG,WAAaxH,MAEpBmD,EAAQ8K,IAGR5K,EAAUA,EAAUtD,EAAEkI,MAAO5E,MAC7BA,EAAQmE,WAAaxH,KAGpBmD,EADuC,mBAA5BnD,MAAKmD,MAAMgI,aACdnL,KAAKmD,MAAMgI,aAAc8C,EAAO5K,GAGhC,GAAIrD,MAAKmD,MAAO8K,EAAO5K,GAG3BF,GAASA,EAAM+M,kBACnBlQ,KAAK8H,QAAS,UAAW9H,KAAMiO,EAAO5K,GACtCF,GAAQ,IAIHA,EAQR,IAAI+I,GAAMzM,EAAOgD,WAAW3B,UAAUqP,MAAQ1Q,EAAOgD,WAAW3B,UAAUoL,GAC1EzM,GAAOgD,WAAW3B,UAAUoL,IAAM,SAAUlE,EAAQ3E,GAEnD,KAAQrD,KAAKmD,MAAMrC,oBAAqBrB,GAAOiC,OAC9C,MAAOwK,GAAI9J,KAAMpC,KAAMgI,EAAQ3E,EAG3BA,IAAWA,EAAQsF,QACvBX,EAAShI,KAAK2I,MAAOX,EAAQ3E,GAG9B,IAAI+M,IAAYrQ,EAAEuM,QAAStE,GAC1BqI,KACApE,KACA9I,EAAQ,IAET6E,GAASoI,EAAapI,GAAWA,MAAkBjI,EAAEkI,MAAOD,EAG5D,KAAM,GAAIkC,GAAI,EAAGA,EAAIlC,EAAO3G,OAAQ6I,IACnC/G,EAAQ6E,EAAOkC,GACP/G,YAAiBrD,GAAS4B,QACjCyB,EAAQ1D,EAAOgD,WAAW3B,UAAUmP,cAAc7N,KAAMpC,KAAMmD,EAAOE,IAGjEF,IACJ8I,EAAM/K,KAAMiC,GAEJnD,KAAKqH,IAAKlE,IAAWnD,KAAKqH,IAAKlE,EAAMmN,KAKvB,MAAZnN,EAAM6D,KACfhH,KAAKuQ,MAAOpN,EAAM6D,IAAO7D,GALzBkN,EAAUnP,KAAMiC,GAYnB8I,GAAQmE,EAAanE,EAAM5K,OAAS4K,EAAO,GAAM,KAASA,CAC1D,IAAI1C,GAAS2C,EAAI9J,KAAMpC,KAAMiM,EAAOlM,EAAEmJ,UAAY6G,OAAO,EAAOpH,OAAO,GAAStF,GAEhF,KAAM6G,EAAI,EAAGA,EAAImG,EAAUhP,OAAQ6I,IAClC/G,EAAQkN,EAAUnG,IAEblK,KAAKqH,IAAKlE,IAAWnD,KAAKqH,IAAKlE,EAAMmN,OACzCtQ,KAAK8H,QAAS,iBAAkB3E,EAAOnD,KAAMqD,EAI/C,OAAOkG,GAMR,IAAIiH,GAAgB1Q,EAAS2C,WAAW3B,UAAU2P,gBAAkB3Q,EAAS2C,WAAW3B,UAAU0P,aAClG1Q,GAAS2C,WAAW3B,UAAU0P,cAAgB,SAAUxI,EAAQ3E,GAE/D,KAAQrD,KAAKmD,MAAMrC,oBAAqBrB,GAAOiC,OAC9C,MAAO8O,GAAcpO,KAAMpC,KAAMgI,EAAQ3E,EAG1C,IAAIqN,KAGJ3Q,GAAE6F,KAAMoC,EAAQ,SAAU7E,GACzBA,EAAQnD,KAAKqH,IAAKlE,IAAaA,GAASnD,KAAKqH,IAAKlE,EAAMmN,KACxDnN,GAASuN,EAASxP,KAAMiC,IACtBnD,KAEH,IAAIuJ,GAASiH,EAAcpO,KAAMpC,KAAM0Q,EAAUrN,EAMjD,OAJAtD,GAAE6F,KAAM8K,EAAU,SAAUvN,GAC3BnD,KAAK8H,QAAS,oBAAqB3E,EAAOnD,KAAMqD,IAC9CrD,MAEIuJ,EAMR,IAAIlB,GAAQ5I,EAAOgD,WAAW3B,UAAU6P,QAAUlR,EAAOgD,WAAW3B,UAAUuH,KAC9E5I,GAAOgD,WAAW3B,UAAUuH,MAAQ,SAAUL,EAAQ3E,GACrDA,EAAUtD,EAAEc,QAAUkP,OAAO,GAAQ1M,EACrC,IAAIkG,GAASlB,EAAMjG,KAAMpC,KAAMgI,EAAQ3E,EAMvC,OAJKrD,MAAKmD,MAAMrC,oBAAqBrB,GAAOiC,OAC3C1B,KAAK8H,QAAS,mBAAoB9H,KAAMqD,GAGlCkG,EAMR,IAAIqH,GAAOnR,EAAOgD,WAAW3B,UAAU+P,OAASpR,EAAOgD,WAAW3B,UAAU8P,IAC5EnR,GAAOgD,WAAW3B,UAAU8P,KAAO,SAAUvN,GAC5C,GAAIkG,GAASqH,EAAKxO,KAAMpC,KAAMqD,EAM9B,OAJKrD,MAAKmD,MAAMrC,oBAAqBrB,GAAOiC,OAC3C1B,KAAK8H,QAAS,mBAAoB9H,KAAMqD,GAGlCkG,EAOR,IAAIzB,GAAUrI,EAAOgD,WAAW3B,UAAUgQ,UAAYrR,EAAOgD,WAAW3B,UAAUgH,ORkHhF,OQjHFrI,GAAOgD,WAAW3B,UAAUgH,QAAU,SAAUiF,GAE/C,KAAQ/M,KAAKmD,MAAMrC,oBAAqBrB,GAAOiC,OAC9C,MAAOoG,GAAQzF,MAAOrC,KAAM+B,UAG7B,IAAmB,QAAdgL,GAAqC,WAAdA,GAAwC,UAAdA,GAAuC,SAAdA,EAAuB,CACrG,GAAIrB,GAAM1L,KACTgC,EAAOD,SAEHhC,GAAEmH,SAAUlF,EAAM,MACtBA,EAAOjC,EAAEgR,QAAS/O,GAGlBA,EAAM,GAAMjC,EAAEkI,MAAOjG,EAAM,KAG5B0B,EAAOjC,WAAWV,IAAK,WACtB+G,EAAQzF,MAAOqJ,EAAK1J,SAIrB8F,GAAQzF,MAAOrC,KAAM+B,UAGtB,OAAO/B,OAIRP,EAAOiC,MAAMb,OAAS,SAAUmQ,EAAYC,GAC3C,GAAIC,GAAQpR,EAAS4B,MAAMb,OAAOwB,MAAOrC,KAAM+B,UAI/C,OAFAmP,GAAMjC,MAAOjP,MAENkR,GR+ECxN","file":"backbone-relational.min.js","sourcesContent":["/**!\n * Backbone Relational v0.10.0 (backbone-relational)\n * ----------------------------------\n * (c) 2011-2016 Paul Uithol and contributors (https://github.com/PaulUithol/Backbone-relational/graphs/contributors)\n * Distributed under MIT license\n *\n * http://backbonerelational.org\n */\n\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('backbone'), require('underscore')) :\n  typeof define === 'function' && define.amd ? define(['backbone', 'underscore'], factory) :\n  (global.BackboneRelational = factory(global.Backbone,global._));\n}(this, function (Backbone,_) { 'use strict';\n\n  var Backbone__default = 'default' in Backbone ? Backbone['default'] : Backbone;\n  _ = 'default' in _ ? _['default'] : _;\n\n  /**\n   * Semaphore mixin; can be used as both binary and counting.\n   **/\n  var Semaphore = {\n  \t_permitsAvailable: null,\n  \t_permitsUsed: 0,\n\n  \tacquire: function acquire() {\n  \t\tif (this._permitsAvailable && this._permitsUsed >= this._permitsAvailable) {\n  \t\t\tthrow new Error('Max permits acquired');\n  \t\t} else {\n  \t\t\tthis._permitsUsed++;\n  \t\t}\n  \t},\n\n  \trelease: function release() {\n  \t\tif (this._permitsUsed === 0) {\n  \t\t\tthrow new Error('All permits released');\n  \t\t} else {\n  \t\t\tthis._permitsUsed--;\n  \t\t}\n  \t},\n\n  \tisLocked: function isLocked() {\n  \t\treturn this._permitsUsed > 0;\n  \t},\n\n  \tsetAvailablePermits: function setAvailablePermits(amount) {\n  \t\tif (this._permitsUsed > amount) {\n  \t\t\tthrow new Error('Available permits cannot be less than used permits');\n  \t\t}\n  \t\tthis._permitsAvailable = amount;\n  \t}\n  };\n\n  /**\n   * A BlockingQueue that accumulates items while blocked (via 'block'),\n   * and processes them when unblocked (via 'unblock').\n   * Process can also be called manually (via 'process').\n   */\n  var BlockingQueue = function BlockingQueue() {\n  \tthis._queue = [];\n  };\n\n  _.extend(BlockingQueue.prototype, Semaphore, {\n  \t_queue: null,\n\n  \tadd: function add(func) {\n  \t\tif (this.isBlocked()) {\n  \t\t\tthis._queue.push(func);\n  \t\t} else {\n  \t\t\tfunc();\n  \t\t}\n  \t},\n\n  \t// Some of the queued events may trigger other blocking events. By\n  \t// copying the queue here it allows queued events to process closer to\n  \t// the natural order.\n  \t//\n  \t// queue events [ 'A', 'B', 'C' ]\n  \t// A handler of 'B' triggers 'D' and 'E'\n  \t// By copying `this._queue` this executes:\n  \t// [ 'A', 'B', 'D', 'E', 'C' ]\n  \t// The same order the would have executed if they didn't have to be\n  \t// delayed and queued.\n  \tprocess: function process() {\n  \t\tvar queue = this._queue;\n  \t\tthis._queue = [];\n  \t\twhile (queue && queue.length) {\n  \t\t\tqueue.shift()();\n  \t\t}\n  \t},\n\n  \tblock: function block() {\n  \t\tthis.acquire();\n  \t},\n\n  \tunblock: function unblock() {\n  \t\tthis.release();\n  \t\tif (!this.isBlocked()) {\n  \t\t\tthis.process();\n  \t\t}\n  \t},\n\n  \tisBlocked: function isBlocked() {\n  \t\treturn this.isLocked();\n  \t}\n  });\n\n  /**\n   * Global event queue. Accumulates external events ('add:<key>', 'remove:<key>' and 'change:<key>')\n   * until the top-level object is fully initialized (see 'Backbone.Relational.Model').\n   */\n  var eventQueue = new BlockingQueue();\n\n  var extend = Backbone.Model.extend;\n\n  var Events = Backbone__default.Events;\n\n  /**\n   * Base object to extend off of. Works similar to how you extend in Backbone\n   */\n  var extendableObject = function extendableObject() {\n    var _initialize;\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    (_initialize = this.initialize).call.apply(_initialize, [this].concat(args));\n  };\n  _.extend(extendableObject.prototype, Events);\n  extendableObject.extend = extend;\n\n  var config = {\n    showWarnings: true\n  };\n\n  var module$1 = config;\n\n  module$1.Collection = Backbone__default.Collection.extend();\n\n  module$1.Semaphore = Semaphore;\n  module$1.BlockingQueue = BlockingQueue;\n  module$1.eventQueue = eventQueue;\n\n  /**\n   * Backbone.Store keeps track of all created (and destruction of) Backbone.Relational.Model.\n   * Handles lookup for relations.\n   */\n  module$1.Store = extendableObject.extend({\n  \tinitialize: function initialize() {\n  \t\tthis._collections = [];\n  \t\tthis._reverseRelations = [];\n  \t\tthis._orphanRelations = [];\n  \t\tthis._subModels = [];\n  \t\tthis._modelScopes = [window];\n  \t},\n\n\n  \t/**\n    * Create a new `Relation`.\n    * @param {Backbone.Relational.Model} [model]\n    * @param {Object} relation\n    * @param {Object} [options]\n    */\n  \tinitializeRelation: function initializeRelation(model, relation, options) {\n  \t\tvar type = !_.isString(relation.type) ? relation.type : module$1[relation.type] || this.getObjectByName(relation.type);\n  \t\tif (type && type.prototype instanceof module$1.Relation) {\n  \t\t\tvar rel = new type(model, relation, options); // Also pushes the new Relation into `model._relations`\n  \t\t} else {\n  \t\t\t\tmodule$1.showWarnings && typeof console !== 'undefined' && console.warn('Relation=%o; missing or invalid relation type!', relation);\n  \t\t\t}\n  \t},\n\n  \t/**\n    * Add a scope for `getObjectByName` to look for model types by name.\n    * @param {Object} scope\n    */\n  \taddModelScope: function addModelScope(scope) {\n  \t\tthis._modelScopes.push(scope);\n  \t},\n\n  \t/**\n    * Remove a scope.\n    * @param {Object} scope\n    */\n  \tremoveModelScope: function removeModelScope(scope) {\n  \t\tthis._modelScopes = _.without(this._modelScopes, scope);\n  \t},\n\n  \t/**\n    * Add a set of subModelTypes to the store, that can be used to resolve the '_superModel'\n    * for a model later in 'setupSuperModel'.\n    *\n    * @param {Backbone.Relational.Model} subModelTypes\n    * @param {Backbone.Relational.Model} superModelType\n    */\n  \taddSubModels: function addSubModels(subModelTypes, superModelType) {\n  \t\tthis._subModels.push({\n  \t\t\t'superModelType': superModelType,\n  \t\t\t'subModels': subModelTypes\n  \t\t});\n  \t},\n\n  \t/**\n    * Check if the given modelType is registered as another model's subModel. If so, add it to the super model's\n    * '_subModels', and set the modelType's '_superModel', '_subModelTypeName', and '_subModelTypeAttribute'.\n    *\n    * @param {Backbone.Relational.Model} modelType\n    */\n  \tsetupSuperModel: function setupSuperModel(modelType) {\n  \t\t_.find(this._subModels, function (subModelDef) {\n  \t\t\treturn _.filter(subModelDef.subModels || [], function (subModelTypeName, typeValue) {\n  \t\t\t\tvar subModelType = this.getObjectByName(subModelTypeName);\n\n  \t\t\t\tif (modelType === subModelType) {\n  \t\t\t\t\t// Set 'modelType' as a child of the found superModel\n  \t\t\t\t\tsubModelDef.superModelType._subModels[typeValue] = modelType;\n\n  \t\t\t\t\t// Set '_superModel', '_subModelTypeValue', and '_subModelTypeAttribute' on 'modelType'.\n  \t\t\t\t\tmodelType._superModel = subModelDef.superModelType;\n  \t\t\t\t\tmodelType._subModelTypeValue = typeValue;\n  \t\t\t\t\tmodelType._subModelTypeAttribute = subModelDef.superModelType.prototype.subModelTypeAttribute;\n  \t\t\t\t\treturn true;\n  \t\t\t\t}\n  \t\t\t}, this).length;\n  \t\t}, this);\n  \t},\n\n  \t/**\n    * Add a reverse relation. Is added to the 'relations' property on model's prototype, and to\n    * existing instances of 'model' in the store as well.\n    * @param {Object} relation\n    * @param {Backbone.Relational.Model} relation.model\n    * @param {String} relation.type\n    * @param {String} relation.key\n    * @param {String|Object} relation.relatedModel\n    */\n  \taddReverseRelation: function addReverseRelation(relation) {\n  \t\tvar exists = _.any(this._reverseRelations, function (rel) {\n  \t\t\treturn _.all(relation || [], function (val, key) {\n  \t\t\t\treturn val === rel[key];\n  \t\t\t});\n  \t\t});\n\n  \t\tif (!exists && relation.model && relation.type) {\n  \t\t\tthis._reverseRelations.push(relation);\n  \t\t\tthis._addRelation(relation.model, relation);\n  \t\t\tthis.retroFitRelation(relation);\n  \t\t}\n  \t},\n\n  \t/**\n    * Deposit a `relation` for which the `relatedModel` can't be resolved at the moment.\n    *\n    * @param {Object} relation\n    */\n  \taddOrphanRelation: function addOrphanRelation(relation) {\n  \t\tvar exists = _.any(this._orphanRelations, function (rel) {\n  \t\t\treturn _.all(relation || [], function (val, key) {\n  \t\t\t\treturn val === rel[key];\n  \t\t\t});\n  \t\t});\n\n  \t\tif (!exists && relation.model && relation.type) {\n  \t\t\tthis._orphanRelations.push(relation);\n  \t\t}\n  \t},\n\n  \t/**\n    * Try to initialize any `_orphanRelation`s\n    */\n  \tprocessOrphanRelations: function processOrphanRelations() {\n  \t\t// Make sure to operate on a copy since we're removing while iterating\n  \t\t_.each(this._orphanRelations.slice(0), function (rel) {\n  \t\t\tvar relatedModel = module$1.store.getObjectByName(rel.relatedModel);\n  \t\t\tif (relatedModel) {\n  \t\t\t\tthis.initializeRelation(null, rel);\n  \t\t\t\tthis._orphanRelations = _.without(this._orphanRelations, rel);\n  \t\t\t}\n  \t\t}, this);\n  \t},\n\n  \t/**\n    *\n    * @param {Backbone.Relational.Model.constructor} type\n    * @param {Object} relation\n    * @private\n    */\n  \t_addRelation: function _addRelation(type, relation) {\n  \t\tif (!type.prototype.relations) {\n  \t\t\ttype.prototype.relations = [];\n  \t\t}\n  \t\ttype.prototype.relations.push(relation);\n\n  \t\t_.each(type._subModels || [], function (subModel) {\n  \t\t\tthis._addRelation(subModel, relation);\n  \t\t}, this);\n  \t},\n\n  \t/**\n    * Add a 'relation' to all existing instances of 'relation.model' in the store\n    * @param {Object} relation\n    */\n  \tretroFitRelation: function retroFitRelation(relation) {\n  \t\tvar coll = this.getCollection(relation.model, false);\n  \t\tcoll && coll.each(function (model) {\n  \t\t\tif (!(model instanceof relation.model)) {\n  \t\t\t\treturn;\n  \t\t\t}\n\n  \t\t\tvar rel = new relation.type(model, relation);\n  \t\t}, this);\n  \t},\n\n  \t/**\n    * Find the Store's collection for a certain type of model.\n    * @param {Backbone.Relational.Model} type\n    * @param {Boolean} [create=true] Should a collection be created if none is found?\n    * @return {module.Collection} A collection if found (or applicable for 'model'), or null\n    */\n  \tgetCollection: function getCollection(type, create) {\n  \t\tif (type instanceof module$1.Model) {\n  \t\t\ttype = type.constructor;\n  \t\t}\n\n  \t\tvar rootModel = type;\n  \t\twhile (rootModel._superModel) {\n  \t\t\trootModel = rootModel._superModel;\n  \t\t}\n\n  \t\tvar coll = _.find(this._collections, function (item) {\n  \t\t\treturn item.model === rootModel;\n  \t\t});\n\n  \t\tif (!coll && create !== false) {\n  \t\t\tcoll = this._createCollection(rootModel);\n  \t\t}\n\n  \t\treturn coll;\n  \t},\n\n  \t/**\n    * Find a model type on one of the modelScopes by name. Names are split on dots.\n    * @param {String} name\n    * @return {Object}\n    */\n  \tgetObjectByName: function getObjectByName(name) {\n  \t\tvar parts = name.split('.'),\n  \t\t    type = null;\n\n  \t\t_.find(this._modelScopes, function (scope) {\n  \t\t\ttype = _.reduce(parts || [], function (memo, val) {\n  \t\t\t\treturn memo ? memo[val] : undefined;\n  \t\t\t}, scope);\n\n  \t\t\tif (type && type !== scope) {\n  \t\t\t\treturn true;\n  \t\t\t}\n  \t\t}, this);\n\n  \t\treturn type;\n  \t},\n\n  \t_createCollection: function _createCollection(type) {\n  \t\tvar coll;\n\n  \t\t// If 'type' is an instance, take its constructor\n  \t\tif (type instanceof module$1.Model) {\n  \t\t\ttype = type.constructor;\n  \t\t}\n\n  \t\t// Type should inherit from Backbone.Relational.Model.\n  \t\tif (type.prototype instanceof module$1.Model) {\n  \t\t\tcoll = new module$1.Collection();\n  \t\t\tcoll.model = type;\n\n  \t\t\tthis._collections.push(coll);\n  \t\t}\n\n  \t\treturn coll;\n  \t},\n\n  \t/**\n    * Find the attribute that is to be used as the `id` on a given object\n    * @param type\n    * @param {String|Number|Object|Backbone.Relational.Model} item\n    * @return {String|Number}\n    */\n  \tresolveIdForItem: function resolveIdForItem(type, item) {\n  \t\tvar id = _.isString(item) || _.isNumber(item) ? item : null;\n\n  \t\tif (id === null) {\n  \t\t\tif (item instanceof module$1.Model) {\n  \t\t\t\tid = item.id;\n  \t\t\t} else if (_.isObject(item)) {\n  \t\t\t\tid = item[type.prototype.idAttribute];\n  \t\t\t}\n  \t\t}\n\n  \t\t// Make all falsy values `null` (except for 0, which could be an id.. see '/issues/179')\n  \t\tif (!id && id !== 0) {\n  \t\t\tid = null;\n  \t\t}\n\n  \t\treturn id;\n  \t},\n\n  \t/**\n    * Find a specific model of a certain `type` in the store\n    * @param type\n    * @param {String|Number|Object|Backbone.Relational.Model} item\n    */\n  \tfind: function find(type, item) {\n  \t\tvar id = this.resolveIdForItem(type, item),\n  \t\t    coll = this.getCollection(type);\n\n  \t\t// Because the found object could be of any of the type's superModel\n  \t\t// types, only return it if it's actually of the type asked for.\n  \t\tif (coll) {\n  \t\t\tvar obj = coll.get(id);\n\n  \t\t\tif (obj instanceof type) {\n  \t\t\t\treturn obj;\n  \t\t\t}\n  \t\t}\n\n  \t\treturn null;\n  \t},\n\n  \t/**\n    * Add a 'model' to its appropriate collection. Retain the original contents of 'model.collection'.\n    * @param {Backbone.Relational.Model} model\n    */\n  \tregister: function register(model) {\n  \t\tvar coll = this.getCollection(model);\n\n  \t\tif (coll) {\n  \t\t\tvar modelColl = model.collection;\n  \t\t\tcoll.add(model);\n  \t\t\tmodel.collection = modelColl;\n  \t\t}\n  \t},\n\n  \t/**\n    * Check if the given model may use the given `id`\n    * @param model\n    * @param [id]\n    */\n  \tcheckId: function checkId(model, id) {\n  \t\tvar coll = this.getCollection(model),\n  \t\t    duplicate = coll && coll.get(id);\n\n  \t\tif (duplicate && model !== duplicate) {\n  \t\t\tif (module$1.showWarnings && typeof console !== 'undefined') {\n  \t\t\t\tconsole.warn('Duplicate id! Old RelationalModel=%o, new RelationalModel=%o', duplicate, model);\n  \t\t\t}\n\n  \t\t\tthrow new Error(\"Cannot instantiate more than one Backbone.Relational.Model with the same id per type!\");\n  \t\t}\n  \t},\n\n  \t/**\n    * Explicitly update a model's id in its store collection\n    * @param {Backbone.Relational.Model} model\n    */\n  \tupdate: function update(model) {\n  \t\tvar coll = this.getCollection(model);\n\n  \t\t// Register a model if it isn't yet (which happens if it was created without an id).\n  \t\tif (!coll.contains(model)) {\n  \t\t\tthis.register(model);\n  \t\t}\n\n  \t\t// This triggers updating the lookup indices kept in a collection\n  \t\tcoll._onModelEvent('change:' + model.idAttribute, model, coll);\n\n  \t\t// Trigger an event on model so related models (having the model's new id in their keyContents) can add it.\n  \t\tmodel.trigger('relational:change:id', model, coll);\n  \t},\n\n  \t/**\n    * Unregister from the store: a specific model, a collection, or a model type.\n    * @param {Backbone.Relational.Model|Backbone.Relational.Model.constructor|module.Collection} type\n    */\n  \tunregister: function unregister(type) {\n  \t\tvar coll, models;\n\n  \t\tif (type instanceof Backbone__default.Model) {\n  \t\t\tcoll = this.getCollection(type);\n  \t\t\tmodels = [type];\n  \t\t} else if (type instanceof module$1.Collection) {\n  \t\t\tcoll = this.getCollection(type.model);\n  \t\t\tmodels = _.clone(type.models);\n  \t\t} else {\n  \t\t\tcoll = this.getCollection(type);\n  \t\t\tmodels = _.clone(coll.models);\n  \t\t}\n\n  \t\t_.each(models, function (model) {\n  \t\t\tthis.stopListening(model);\n  \t\t\t_.invoke(model.getRelations(), 'stopListening');\n  \t\t}, this);\n\n  \t\t// If we've unregistered an entire store collection, reset the collection (which is much faster).\n  \t\t// Otherwise, remove each model one by one.\n  \t\tif (_.contains(this._collections, type)) {\n  \t\t\tcoll.reset([]);\n  \t\t} else {\n  \t\t\t_.each(models, function (model) {\n  \t\t\t\tif (coll.get(model)) {\n  \t\t\t\t\tcoll.remove(model);\n  \t\t\t\t} else {\n  \t\t\t\t\tcoll.trigger('relational:remove', model, coll);\n  \t\t\t\t}\n  \t\t\t}, this);\n  \t\t}\n  \t},\n\n  \t/**\n    * Reset the `store` to it's original state. The `reverseRelations` are kept though, since attempting to\n    * re-initialize these on models would lead to a large amount of warnings.\n    */\n  \treset: function reset() {\n  \t\tthis.stopListening();\n\n  \t\t// Unregister each collection to remove event listeners\n  \t\t_.each(this._collections, function (coll) {\n  \t\t\tthis.unregister(coll);\n  \t\t}, this);\n\n  \t\tthis._collections = [];\n  \t\tthis._subModels = [];\n  \t\tthis._modelScopes = [window];\n  \t}\n  });\n\n  module$1.store = new module$1.Store();\n\n  /**\n   * The main Relation class, from which 'HasOne' and 'HasMany' inherit. Internally, 'relational:<key>' events\n   * are used to regulate addition and removal of models from relations.\n   *\n   * @param {Backbone.Relational.Model} [instance] Model that this relation is created for. If no model is supplied,\n   *      Relation just tries to instantiate it's `reverseRelation` if specified, and bails out after that.\n   * @param {Object} options\n   * @param {string} options.key\n   * @param {Backbone.Relational.Model.constructor} options.relatedModel\n   * @param {Boolean|String} [options.includeInJSON=true] Serialize the given attribute for related model(s)' in toJSON, or just their ids.\n   * @param {Boolean} [options.createModels=true] Create objects from the contents of keys if the object is not found in Backbone.store.\n   * @param {Object} [options.reverseRelation] Specify a bi-directional relation. If provided, Relation will reciprocate\n   *    the relation to the 'relatedModel'. Required and optional properties match 'options', except that it also needs\n   *    {Backbone.Relation|String} type ('HasOne' or 'HasMany').\n   * @param {Object} opts\n   */\n  module$1.Relation = extendableObject.extend(Semaphore).extend({\n  \toptions: {\n  \t\tcreateModels: true,\n  \t\tincludeInJSON: true,\n  \t\tisAutoRelation: false,\n  \t\tautoFetch: false,\n  \t\tparse: false\n  \t},\n\n  \tinstance: null,\n  \tkey: null,\n  \tkeyContents: null,\n  \trelatedModel: null,\n  \trelatedCollection: null,\n  \treverseRelation: null,\n  \trelated: null,\n\n  \tconstructor: function constructor(instance, options, opts) {\n  \t\tthis.instance = instance;\n  \t\t// Make sure 'options' is sane, and fill with defaults from subclasses and this object's prototype\n  \t\toptions = _.isObject(options) ? options : {};\n  \t\tthis.reverseRelation = _.defaults(options.reverseRelation || {}, this.options.reverseRelation);\n  \t\tthis.options = _.defaults(options, this.options, module$1.Relation.prototype.options);\n\n  \t\tthis.reverseRelation.type = !_.isString(this.reverseRelation.type) ? this.reverseRelation.type : module$1[this.reverseRelation.type] || module$1.store.getObjectByName(this.reverseRelation.type);\n\n  \t\tthis.key = this.options.key;\n  \t\tthis.keySource = this.options.keySource || this.key;\n  \t\tthis.keyDestination = this.options.keyDestination || this.keySource || this.key;\n\n  \t\tthis.model = this.options.model || this.instance.constructor;\n\n  \t\tthis.relatedModel = this.options.relatedModel;\n\n  \t\tif (_.isUndefined(this.relatedModel)) {\n  \t\t\tthis.relatedModel = this.model;\n  \t\t}\n\n  \t\tif (_.isFunction(this.relatedModel) && !(this.relatedModel.prototype instanceof module$1.Model)) {\n  \t\t\tthis.relatedModel = _.result(this, 'relatedModel');\n  \t\t}\n  \t\tif (_.isString(this.relatedModel)) {\n  \t\t\tthis.relatedModel = module$1.store.getObjectByName(this.relatedModel);\n  \t\t}\n\n  \t\tif (!this.checkPreconditions()) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\t// Add the reverse relation on 'relatedModel' to the store's reverseRelations\n  \t\tif (!this.options.isAutoRelation && this.reverseRelation.type && this.reverseRelation.key) {\n  \t\t\tmodule$1.store.addReverseRelation(_.defaults({\n  \t\t\t\tisAutoRelation: true,\n  \t\t\t\tmodel: this.relatedModel,\n  \t\t\t\trelatedModel: this.model,\n  \t\t\t\treverseRelation: this.options // current relation is the 'reverseRelation' for its own reverseRelation\n  \t\t\t}, this.reverseRelation // Take further properties from this.reverseRelation (type, key, etc.)\n  \t\t\t));\n  \t\t}\n\n  \t\tif (instance) {\n  \t\t\tvar contentKey = this.keySource;\n  \t\t\tif (contentKey !== this.key && _.isObject(this.instance.get(this.key))) {\n  \t\t\t\tcontentKey = this.key;\n  \t\t\t}\n\n  \t\t\tthis.setKeyContents(this.instance.get(contentKey));\n  \t\t\tthis.relatedCollection = module$1.store.getCollection(this.relatedModel);\n\n  \t\t\t// Explicitly clear 'keySource', to prevent a leaky abstraction if 'keySource' differs from 'key'.\n  \t\t\tif (this.keySource !== this.key) {\n  \t\t\t\tdelete this.instance.attributes[this.keySource];\n  \t\t\t}\n\n  \t\t\t// Add this Relation to instance._relations\n  \t\t\tthis.instance._relations[this.key] = this;\n\n  \t\t\tthis.initialize(opts);\n\n  \t\t\tif (this.options.autoFetch) {\n  \t\t\t\tthis.instance.getAsync(this.key, _.isObject(this.options.autoFetch) ? this.options.autoFetch : {});\n  \t\t\t}\n\n  \t\t\t// When 'relatedModel' are created or destroyed, check if it affects this relation.\n  \t\t\tthis.listenTo(this.instance, 'destroy', this.destroy).listenTo(this.relatedCollection, 'relational:add relational:change:id', this.tryAddRelated).listenTo(this.relatedCollection, 'relational:remove', this.removeRelated);\n  \t\t}\n  \t},\n\n\n  \t/**\n    * Check several pre-conditions.\n    * @return {Boolean} True if pre-conditions are satisfied, false if they're not.\n    */\n  \tcheckPreconditions: function checkPreconditions() {\n  \t\tvar i = this.instance,\n  \t\t    k = this.key,\n  \t\t    m = this.model,\n  \t\t    rm = this.relatedModel,\n  \t\t    warn = module$1.showWarnings && typeof console !== 'undefined';\n\n  \t\tif (!m || !k || !rm) {\n  \t\t\twarn && console.warn('Relation=%o: missing model, key or relatedModel (%o, %o, %o).', this, m, k, rm);\n  \t\t\treturn false;\n  \t\t}\n  \t\t// Check if the type in 'model' inherits from Backbone.Relational.Model\n  \t\tif (!(m.prototype instanceof module$1.Model)) {\n  \t\t\twarn && console.warn('Relation=%o: model does not inherit from Backbone.Relational.Model (%o).', this, i);\n  \t\t\treturn false;\n  \t\t}\n  \t\t// Check if the type in 'relatedModel' inherits from Backbone.Relational.Model\n  \t\tif (!(rm.prototype instanceof module$1.Model)) {\n  \t\t\twarn && console.warn('Relation=%o: relatedModel does not inherit from Backbone.Relational.Model (%o).', this, rm);\n  \t\t\treturn false;\n  \t\t}\n  \t\t// Check if this is not a HasMany, and the reverse relation is HasMany as well\n  \t\tif (this instanceof module$1.HasMany && this.reverseRelation.type === module$1.HasMany) {\n  \t\t\twarn && console.warn('Relation=%o: relation is a HasMany, and the reverseRelation is HasMany as well.', this);\n  \t\t\treturn false;\n  \t\t}\n  \t\t// Check if we're not attempting to create a relationship on a `key` that's already used.\n  \t\tif (i && _.keys(i._relations).length) {\n  \t\t\tvar existing = _.find(i._relations, function (rel) {\n  \t\t\t\treturn rel.key === k;\n  \t\t\t}, this);\n\n  \t\t\tif (existing) {\n  \t\t\t\twarn && console.warn('Cannot create relation=%o on %o for model=%o: already taken by relation=%o.', this, k, i, existing);\n  \t\t\t\treturn false;\n  \t\t\t}\n  \t\t}\n\n  \t\treturn true;\n  \t},\n\n  \t/**\n    * Set the related model(s) for this relation\n    * @param {Backbone.Model|module.Collection} related\n    */\n  \tsetRelated: function setRelated(related) {\n  \t\tthis.related = related;\n  \t\tthis.instance.attributes[this.key] = related;\n  \t},\n\n  \t/**\n    * Determine if a relation (on a different RelationalModel) is the reverse\n    * relation of the current one.\n    * @param {Backbone.Relation} relation\n    * @return {Boolean}\n    */\n  \t_isReverseRelation: function _isReverseRelation(relation) {\n  \t\treturn relation.instance instanceof this.relatedModel && this.reverseRelation.key === relation.key && this.key === relation.reverseRelation.key;\n  \t},\n\n  \t/**\n    * Get the reverse relations (pointing back to 'this.key' on 'this.instance') for the currently related model(s).\n    * @param {Backbone.Relational.Model} [model] Get the reverse relations for a specific model.\n    *    If not specified, 'this.related' is used.\n    * @return {Backbone.Relation[]}\n    */\n  \tgetReverseRelations: function getReverseRelations(model) {\n  \t\tvar reverseRelations = [];\n  \t\t// Iterate over 'model', 'this.related.models' (if this.related is a module.Collection), or wrap 'this.related' in an array.\n  \t\tvar models = !_.isUndefined(model) ? [model] : this.related && (this.related.models || [this.related]),\n  \t\t    relations = null,\n  \t\t    relation = null;\n\n  \t\tfor (var i = 0; i < (models || []).length; i++) {\n  \t\t\trelations = models[i].getRelations() || [];\n\n  \t\t\tfor (var j = 0; j < relations.length; j++) {\n  \t\t\t\trelation = relations[j];\n\n  \t\t\t\tif (this._isReverseRelation(relation)) {\n  \t\t\t\t\treverseRelations.push(relation);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n\n  \t\treturn reverseRelations;\n  \t},\n\n  \t/**\n    * When `this.instance` is destroyed, cleanup our relations.\n    * Get reverse relation, call removeRelated on each.\n    */\n  \tdestroy: function destroy() {\n  \t\tthis.stopListening();\n\n  \t\tif (this instanceof module$1.HasOne) {\n  \t\t\tthis.setRelated(null);\n  \t\t} else if (this instanceof module$1.HasMany) {\n  \t\t\tthis.setRelated(this._prepareCollection());\n  \t\t}\n\n  \t\t_.each(this.getReverseRelations(), function (relation) {\n  \t\t\trelation.removeRelated(this.instance);\n  \t\t}, this);\n  \t}\n  });\n\n  module$1.HasOne = module$1.Relation.extend({\n  \toptions: {\n  \t\treverseRelation: { type: 'HasMany' }\n  \t},\n\n  \tinitialize: function initialize(opts) {\n  \t\tthis.listenTo(this.instance, 'relational:change:' + this.key, this.onChange);\n\n  \t\tvar related = this.findRelated(opts);\n  \t\tthis.setRelated(related);\n\n  \t\t// Notify new 'related' object of the new relation.\n  \t\t_.each(this.getReverseRelations(), function (relation) {\n  \t\t\trelation.addRelated(this.instance, opts);\n  \t\t}, this);\n  \t},\n\n  \t/**\n    * Find related Models.\n    * @param {Object} [options]\n    * @return {Backbone.Model}\n    */\n  \tfindRelated: function findRelated(options) {\n  \t\tvar related = null;\n\n  \t\toptions = _.defaults({ parse: this.options.parse }, options);\n\n  \t\tif (this.keyContents instanceof this.relatedModel) {\n  \t\t\trelated = this.keyContents;\n  \t\t} else if (this.keyContents || this.keyContents === 0) {\n  \t\t\t// since 0 can be a valid `id` as well\n  \t\t\tvar opts = _.defaults({ create: this.options.createModels }, options);\n  \t\t\trelated = this.relatedModel.findOrCreate(this.keyContents, opts);\n  \t\t}\n\n  \t\t// Nullify `keyId` if we have a related model; in case it was already part of the relation\n  \t\tif (related) {\n  \t\t\tthis.keyId = null;\n  \t\t}\n\n  \t\treturn related;\n  \t},\n\n  \t/**\n    * Normalize and reduce `keyContents` to an `id`, for easier comparison\n    * @param {String|Number|Backbone.Model} keyContents\n    */\n  \tsetKeyContents: function setKeyContents(keyContents) {\n  \t\tthis.keyContents = keyContents;\n  \t\tthis.keyId = module$1.store.resolveIdForItem(this.relatedModel, this.keyContents);\n  \t},\n\n  \t/**\n    * Event handler for `change:<key>`.\n    * If the key is changed, notify old & new reverse relations and initialize the new relation.\n    */\n  \tonChange: function onChange(model, attr, options) {\n  \t\t// Don't accept recursive calls to onChange (like onChange->findRelated->findOrCreate->initializeRelations->addRelated->onChange)\n  \t\tif (this.isLocked()) {\n  \t\t\treturn;\n  \t\t}\n  \t\tthis.acquire();\n  \t\toptions = options ? _.clone(options) : {};\n\n  \t\t// 'options.__related' is set by 'addRelated'/'removeRelated'. If it is set, the change\n  \t\t// is the result of a call from a relation. If it's not, the change is the result of\n  \t\t// a 'set' call on this.instance.\n  \t\tvar changed = _.isUndefined(options.__related),\n  \t\t    oldRelated = changed ? this.related : options.__related;\n\n  \t\tif (changed) {\n  \t\t\tthis.setKeyContents(attr);\n  \t\t\tvar related = this.findRelated(options);\n  \t\t\tthis.setRelated(related);\n  \t\t}\n\n  \t\t// Notify old 'related' object of the terminated relation\n  \t\tif (oldRelated && this.related !== oldRelated) {\n  \t\t\t_.each(this.getReverseRelations(oldRelated), function (relation) {\n  \t\t\t\trelation.removeRelated(this.instance, null, options);\n  \t\t\t}, this);\n  \t\t}\n\n  \t\t// Notify new 'related' object of the new relation. Note we do re-apply even if this.related is oldRelated;\n  \t\t// that can be necessary for bi-directional relations if 'this.instance' was created after 'this.related'.\n  \t\t// In that case, 'this.instance' will already know 'this.related', but the reverse might not exist yet.\n  \t\t_.each(this.getReverseRelations(), function (relation) {\n  \t\t\trelation.addRelated(this.instance, options);\n  \t\t}, this);\n\n  \t\t// Fire the 'change:<key>' event if 'related' was updated\n  \t\tif (!options.silent && this.related !== oldRelated) {\n  \t\t\tvar dit = this;\n  \t\t\tthis.changed = true;\n  \t\t\tmodule$1.eventQueue.add(function () {\n  \t\t\t\tdit.instance.trigger('change:' + dit.key, dit.instance, dit.related, options, true);\n  \t\t\t\tdit.changed = false;\n  \t\t\t});\n  \t\t}\n  \t\tthis.release();\n  \t},\n\n  \t/**\n    * If a new 'this.relatedModel' appears in the 'store', try to match it to the last set 'keyContents'\n    */\n  \ttryAddRelated: function tryAddRelated(model, coll, options) {\n  \t\tif ((this.keyId || this.keyId === 0) && model.id === this.keyId) {\n  \t\t\t// since 0 can be a valid `id` as well\n  \t\t\tthis.addRelated(model, options);\n  \t\t\tthis.keyId = null;\n  \t\t}\n  \t},\n\n  \taddRelated: function addRelated(model, options) {\n  \t\t// Allow 'model' to set up its relations before proceeding.\n  \t\t// (which can result in a call to 'addRelated' from a relation of 'model')\n  \t\tvar dit = this;\n  \t\tmodel.queue(function () {\n  \t\t\tif (model !== dit.related) {\n  \t\t\t\tvar oldRelated = dit.related || null;\n  \t\t\t\tdit.setRelated(model);\n  \t\t\t\tdit.onChange(dit.instance, model, _.defaults({ __related: oldRelated }, options));\n  \t\t\t}\n  \t\t});\n  \t},\n\n  \tremoveRelated: function removeRelated(model, coll, options) {\n  \t\tif (!this.related) {\n  \t\t\treturn;\n  \t\t}\n\n  \t\tif (model === this.related) {\n  \t\t\tvar oldRelated = this.related || null;\n  \t\t\tthis.setRelated(null);\n  \t\t\tthis.onChange(this.instance, model, _.defaults({ __related: oldRelated }, options));\n  \t\t}\n  \t}\n  });\n\n  module$1.HasMany = module$1.Relation.extend({\n  \tcollectionType: null,\n\n  \toptions: {\n  \t\treverseRelation: { type: 'HasOne' },\n  \t\tcollectionType: module$1.Collection,\n  \t\tcollectionKey: true,\n  \t\tcollectionOptions: {}\n  \t},\n\n  \tinitialize: function initialize(opts) {\n  \t\tthis.listenTo(this.instance, 'relational:change:' + this.key, this.onChange);\n\n  \t\t// Handle a custom 'collectionType'\n  \t\tthis.collectionType = this.options.collectionType;\n  \t\tif (_.isFunction(this.collectionType) && this.collectionType !== module$1.Collection && !(this.collectionType.prototype instanceof module$1.Collection)) {\n  \t\t\tthis.collectionType = _.result(this, 'collectionType');\n  \t\t}\n  \t\tif (_.isString(this.collectionType)) {\n  \t\t\tthis.collectionType = module$1.store.getObjectByName(this.collectionType);\n  \t\t}\n  \t\tif (this.collectionType !== module$1.Collection && !(this.collectionType.prototype instanceof module$1.Collection)) {\n  \t\t\tthrow new Error('`collectionType` must inherit from module.Collection');\n  \t\t}\n\n  \t\tvar related = this.findRelated(opts);\n  \t\tthis.setRelated(related);\n  \t},\n\n  \t/**\n    * Bind events and setup collectionKeys for a collection that is to be used as the backing store for a HasMany.\n    * If no 'collection' is supplied, a new collection will be created of the specified 'collectionType' option.\n    * @param {module.Collection} [collection]\n    * @return {module.Collection}\n    */\n  \t_prepareCollection: function _prepareCollection(collection) {\n  \t\tif (this.related) {\n  \t\t\tthis.stopListening(this.related);\n  \t\t}\n\n  \t\tif (!collection || !(collection instanceof module$1.Collection)) {\n  \t\t\tvar options = _.isFunction(this.options.collectionOptions) ? this.options.collectionOptions(this.instance) : this.options.collectionOptions;\n\n  \t\t\tcollection = new this.collectionType(null, options);\n  \t\t}\n\n  \t\tcollection.model = this.relatedModel;\n\n  \t\tif (this.options.collectionKey) {\n  \t\t\tvar key = this.options.collectionKey === true ? this.options.reverseRelation.key : this.options.collectionKey;\n\n  \t\t\tif (collection[key] && collection[key] !== this.instance) {\n  \t\t\t\tif (module$1.showWarnings && typeof console !== 'undefined') {\n  \t\t\t\t\tconsole.warn('Relation=%o; collectionKey=%s already exists on collection=%o', this, key, this.options.collectionKey);\n  \t\t\t\t}\n  \t\t\t} else if (key) {\n  \t\t\t\tcollection[key] = this.instance;\n  \t\t\t}\n  \t\t}\n\n  \t\tthis.listenTo(collection, 'relational:add', this.handleAddition).listenTo(collection, 'relational:remove', this.handleRemoval).listenTo(collection, 'relational:reset', this.handleReset);\n\n  \t\treturn collection;\n  \t},\n\n  \t/**\n    * Find related Models.\n    * @param {Object} [options]\n    * @return {module.Collection}\n    */\n  \tfindRelated: function findRelated(options) {\n  \t\tvar related = null;\n\n  \t\toptions = _.defaults({ parse: this.options.parse }, options);\n\n  \t\t// Replace 'this.related' by 'this.keyContents' if it is a module.Collection\n  \t\tif (this.keyContents instanceof module$1.Collection) {\n  \t\t\tthis._prepareCollection(this.keyContents);\n  \t\t\trelated = this.keyContents;\n  \t\t}\n  \t\t// Otherwise, 'this.keyContents' should be an array of related object ids.\n  \t\t// Re-use the current 'this.related' if it is a module.Collection; otherwise, create a new collection.\n  \t\telse {\n  \t\t\t\tvar toAdd = [];\n\n  \t\t\t\t_.each(this.keyContents, function (attributes) {\n  \t\t\t\t\tvar model = null;\n\n  \t\t\t\t\tif (attributes instanceof this.relatedModel) {\n  \t\t\t\t\t\tmodel = attributes;\n  \t\t\t\t\t} else {\n  \t\t\t\t\t\t// If `merge` is true, update models here, instead of during update.\n  \t\t\t\t\t\tmodel = _.isObject(attributes) && options.parse && this.relatedModel.prototype.parse ? this.relatedModel.prototype.parse(_.clone(attributes), options) : attributes;\n  \t\t\t\t\t}\n\n  \t\t\t\t\tmodel && toAdd.push(model);\n  \t\t\t\t}, this);\n\n  \t\t\t\tif (this.related instanceof module$1.Collection) {\n  \t\t\t\t\trelated = this.related;\n  \t\t\t\t} else {\n  \t\t\t\t\trelated = this._prepareCollection();\n  \t\t\t\t}\n\n  \t\t\t\t// By now, `parse` will already have been executed just above for models if specified.\n  \t\t\t\t// Disable to prevent additional calls.\n  \t\t\t\trelated.set(toAdd, _.defaults({ parse: false }, options));\n  \t\t\t}\n\n  \t\t// Remove entries from `keyIds` that were already part of the relation (and are thus 'unchanged')\n  \t\tthis.keyIds = _.difference(this.keyIds, _.pluck(related.models, 'id'));\n\n  \t\treturn related;\n  \t},\n\n  \t/**\n    * Normalize and reduce `keyContents` to a list of `ids`, for easier comparison\n    * @param {String|Number|String[]|Number[]|module.Collection} keyContents\n    */\n  \tsetKeyContents: function setKeyContents(keyContents) {\n  \t\tthis.keyContents = keyContents instanceof module$1.Collection ? keyContents : null;\n  \t\tthis.keyIds = [];\n\n  \t\tif (!this.keyContents && (keyContents || keyContents === 0)) {\n  \t\t\t// since 0 can be a valid `id` as well\n  \t\t\t// Handle cases the an API/user supplies just an Object/id instead of an Array\n  \t\t\tthis.keyContents = _.isArray(keyContents) ? keyContents : [keyContents];\n\n  \t\t\t_.each(this.keyContents, function (item) {\n  \t\t\t\tvar itemId = module$1.store.resolveIdForItem(this.relatedModel, item);\n  \t\t\t\tif (itemId || itemId === 0) {\n  \t\t\t\t\tthis.keyIds.push(itemId);\n  \t\t\t\t}\n  \t\t\t}, this);\n  \t\t}\n  \t},\n\n  \t/**\n    * Event handler for `change:<key>`.\n    * If the contents of the key are changed, notify old & new reverse relations and initialize the new relation.\n    */\n  \tonChange: function onChange(model, attr, options) {\n  \t\toptions = options ? _.clone(options) : {};\n  \t\tthis.setKeyContents(attr);\n  \t\tthis.changed = false;\n\n  \t\tvar related = this.findRelated(options);\n  \t\tthis.setRelated(related);\n\n  \t\tif (!options.silent) {\n  \t\t\tvar dit = this;\n  \t\t\tmodule$1.eventQueue.add(function () {\n  \t\t\t\t// The `changed` flag can be set in `handleAddition` or `handleRemoval`\n  \t\t\t\tif (dit.changed) {\n  \t\t\t\t\tdit.instance.trigger('change:' + dit.key, dit.instance, dit.related, options, true);\n  \t\t\t\t\tdit.changed = false;\n  \t\t\t\t}\n  \t\t\t});\n  \t\t}\n  \t},\n\n  \t/**\n    * When a model is added to a 'HasMany', trigger 'add' on 'this.instance' and notify reverse relations.\n    * (should be 'HasOne', must set 'this.instance' as their related).\n    */\n  \thandleAddition: function handleAddition(model, coll, options) {\n  \t\t//console.debug('handleAddition called; args=%o', arguments);\n  \t\toptions = options ? _.clone(options) : {};\n  \t\tthis.changed = true;\n\n  \t\t_.each(this.getReverseRelations(model), function (relation) {\n  \t\t\trelation.addRelated(this.instance, options);\n  \t\t}, this);\n\n  \t\t// Only trigger 'add' once the newly added model is initialized (so, has its relations set up)\n  \t\tvar dit = this;\n  \t\t!options.silent && module$1.eventQueue.add(function () {\n  \t\t\tdit.instance.trigger('add:' + dit.key, model, dit.related, options);\n  \t\t});\n  \t},\n\n  \t/**\n    * When a model is removed from a 'HasMany', trigger 'remove' on 'this.instance' and notify reverse relations.\n    * (should be 'HasOne', which should be nullified)\n    */\n  \thandleRemoval: function handleRemoval(model, coll, options) {\n  \t\t//console.debug('handleRemoval called; args=%o', arguments);\n  \t\toptions = options ? _.clone(options) : {};\n  \t\tthis.changed = true;\n\n  \t\t_.each(this.getReverseRelations(model), function (relation) {\n  \t\t\trelation.removeRelated(this.instance, null, options);\n  \t\t}, this);\n\n  \t\tvar dit = this;\n  \t\t!options.silent && module$1.eventQueue.add(function () {\n  \t\t\tdit.instance.trigger('remove:' + dit.key, model, dit.related, options);\n  \t\t});\n  \t},\n\n  \thandleReset: function handleReset(coll, options) {\n  \t\tvar dit = this;\n  \t\toptions = options ? _.clone(options) : {};\n  \t\t!options.silent && module$1.eventQueue.add(function () {\n  \t\t\tdit.instance.trigger('reset:' + dit.key, dit.related, options);\n  \t\t});\n  \t},\n\n  \ttryAddRelated: function tryAddRelated(model, coll, options) {\n  \t\tvar item = _.contains(this.keyIds, model.id);\n\n  \t\tif (item) {\n  \t\t\tthis.addRelated(model, options);\n  \t\t\tthis.keyIds = _.without(this.keyIds, model.id);\n  \t\t}\n  \t},\n\n  \taddRelated: function addRelated(model, options) {\n  \t\t// Allow 'model' to set up its relations before proceeding.\n  \t\t// (which can result in a call to 'addRelated' from a relation of 'model')\n  \t\tvar dit = this;\n  \t\tmodel.queue(function () {\n  \t\t\tif (dit.related && !dit.related.get(model)) {\n  \t\t\t\tdit.related.add(model, _.defaults({ parse: false }, options));\n  \t\t\t}\n  \t\t});\n  \t},\n\n  \tremoveRelated: function removeRelated(model, coll, options) {\n  \t\tif (this.related.get(model)) {\n  \t\t\tthis.related.remove(model, options);\n  \t\t}\n  \t}\n  });\n\n  /**\n   * A type of Backbone.Model that also maintains relations to other models and collections.\n   * New events when compared to the original:\n   *  - 'add:<key>' (model, related collection, options)\n   *  - 'remove:<key>' (model, related collection, options)\n   *  - 'change:<key>' (model, related model or collection, options)\n   */\n  module$1.Model = Backbone__default.Model.extend(Semaphore).extend({\n  \trelations: null, // Relation descriptions on the prototype\n  \t_relations: null, // Relation instances\n  \t_isInitialized: false,\n  \t_deferProcessing: false,\n  \t_queue: null,\n  \t_attributeChangeFired: false, // Keeps track of `change` event firing under some conditions (like nested `set`s)\n\n  \tsubModelTypeAttribute: 'type',\n  \tsubModelTypes: null,\n\n  \tconstructor: function constructor(attributes, options) {\n  \t\t// Nasty hack, for cases like 'model.get( <HasMany key> ).add( item )'.\n  \t\t// Defer 'processQueue', so that when 'Relation.createModels' is used we trigger 'HasMany'\n  \t\t// collection events only after the model is really fully set up.\n  \t\t// Example: event for \"p.on( 'add:jobs' )\" -> \"p.get('jobs').add( { company: c.id, person: p.id } )\".\n  \t\tif (options && options.collection) {\n  \t\t\tvar dit = this,\n  \t\t\t    collection = this.collection = options.collection;\n\n  \t\t\t// Prevent `collection` from cascading down to nested models; they shouldn't go into this `if` clause.\n  \t\t\tdelete options.collection;\n\n  \t\t\tthis._deferProcessing = true;\n\n  \t\t\tvar processQueue = function processQueue(model) {\n  \t\t\t\tif (model === dit) {\n  \t\t\t\t\tdit._deferProcessing = false;\n  \t\t\t\t\tdit.processQueue();\n  \t\t\t\t\tcollection.off('relational:add', processQueue);\n  \t\t\t\t}\n  \t\t\t};\n  \t\t\tcollection.on('relational:add', processQueue);\n\n  \t\t\t// So we do process the queue eventually, regardless of whether this model actually gets added to 'options.collection'.\n  \t\t\t_.defer(function () {\n  \t\t\t\tprocessQueue(dit);\n  \t\t\t});\n  \t\t}\n\n  \t\tmodule$1.store.processOrphanRelations();\n  \t\tmodule$1.store.listenTo(this, 'relational:unregister', module$1.store.unregister);\n\n  \t\tthis._queue = new module$1.BlockingQueue();\n  \t\tthis._queue.block();\n  \t\tmodule$1.eventQueue.block();\n\n  \t\ttry {\n  \t\t\tBackbone__default.Model.apply(this, arguments);\n  \t\t} finally {\n  \t\t\t// Try to run the global queue holding external events\n  \t\t\tmodule$1.eventQueue.unblock();\n  \t\t}\n  \t},\n\n  \t/**\n    * Override 'trigger' to queue 'change' and 'change:*' events\n    */\n  \ttrigger: function trigger(eventName) {\n  \t\tif (eventName.length > 5 && eventName.indexOf('change') === 0) {\n  \t\t\tvar dit = this,\n  \t\t\t    args = arguments;\n\n  \t\t\tif (!module$1.eventQueue.isLocked()) {\n  \t\t\t\t// If we're not in a more complicated nested scenario, fire the change event right away\n  \t\t\t\tBackbone__default.Model.prototype.trigger.apply(dit, args);\n  \t\t\t} else {\n  \t\t\t\tmodule$1.eventQueue.add(function () {\n  \t\t\t\t\t// Determine if the `change` event is still valid, now that all relations are populated\n  \t\t\t\t\tvar changed = true;\n  \t\t\t\t\tif (eventName === 'change') {\n  \t\t\t\t\t\t// `hasChanged` may have gotten reset by nested calls to `set`.\n  \t\t\t\t\t\tchanged = dit.hasChanged() || dit._attributeChangeFired;\n  \t\t\t\t\t\tdit._attributeChangeFired = false;\n  \t\t\t\t\t} else {\n  \t\t\t\t\t\tvar attr = eventName.slice(7),\n  \t\t\t\t\t\t    rel = dit.getRelation(attr);\n\n  \t\t\t\t\t\tif (rel) {\n  \t\t\t\t\t\t\t// If `attr` is a relation, `change:attr` get triggered from `Relation.onChange`.\n  \t\t\t\t\t\t\t// These take precedence over `change:attr` events triggered by `Model.set`.\n  \t\t\t\t\t\t\t// The relation sets a fourth attribute to `true`. If this attribute is present,\n  \t\t\t\t\t\t\t// continue triggering this event; otherwise, it's from `Model.set` and should be stopped.\n  \t\t\t\t\t\t\tchanged = args[4] === true;\n\n  \t\t\t\t\t\t\t// If this event was triggered by a relation, set the right value in `this.changed`\n  \t\t\t\t\t\t\t// (a Collection or Model instead of raw data).\n  \t\t\t\t\t\t\tif (changed) {\n  \t\t\t\t\t\t\t\tdit.changed[attr] = args[2];\n  \t\t\t\t\t\t\t}\n  \t\t\t\t\t\t\t// Otherwise, this event is from `Model.set`. If the relation doesn't report a change,\n  \t\t\t\t\t\t\t// remove attr from `dit.changed` so `hasChanged` doesn't take it into account.\n  \t\t\t\t\t\t\telse if (!rel.changed) {\n  \t\t\t\t\t\t\t\t\tdelete dit.changed[attr];\n  \t\t\t\t\t\t\t\t}\n  \t\t\t\t\t\t} else if (changed) {\n  \t\t\t\t\t\t\tdit._attributeChangeFired = true;\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n\n  \t\t\t\t\tchanged && Backbone__default.Model.prototype.trigger.apply(dit, args);\n  \t\t\t\t});\n  \t\t\t}\n  \t\t} else if (eventName === 'destroy') {\n  \t\t\tBackbone__default.Model.prototype.trigger.apply(this, arguments);\n  \t\t\tmodule$1.store.unregister(this);\n  \t\t} else {\n  \t\t\tBackbone__default.Model.prototype.trigger.apply(this, arguments);\n  \t\t}\n\n  \t\treturn this;\n  \t},\n\n  \t/**\n    * Initialize Relations present in this.relations; determine the type (HasOne/HasMany), then creates a new instance.\n    * Invoked in the first call so 'set' (which is made from the Backbone.Model constructor).\n    */\n  \tinitializeRelations: function initializeRelations(options) {\n  \t\tthis.acquire(); // Setting up relations often also involve calls to 'set', and we only want to enter this function once\n  \t\tthis._relations = {};\n\n  \t\t_.each(this.relations || [], function (rel) {\n  \t\t\tmodule$1.store.initializeRelation(this, rel, options);\n  \t\t}, this);\n\n  \t\tthis._isInitialized = true;\n  \t\tthis.release();\n  \t\tthis.processQueue();\n  \t},\n\n  \t/**\n    * When new values are set, notify this model's relations (also if options.silent is set).\n    * (called from `set`; Relation.setRelated locks this model before calling 'set' on it to prevent loops)\n    * @param {Object} [changedAttrs]\n    * @param {Object} [options]\n    */\n  \tupdateRelations: function updateRelations(changedAttrs, options) {\n  \t\tif (this._isInitialized && !this.isLocked()) {\n  \t\t\t_.each(this._relations, function (rel) {\n  \t\t\t\tif (!changedAttrs || rel.keySource in changedAttrs || rel.key in changedAttrs) {\n  \t\t\t\t\t// Fetch data in `rel.keySource` if data got set in there, or `rel.key` otherwise\n  \t\t\t\t\tvar value = this.attributes[rel.keySource] || this.attributes[rel.key],\n  \t\t\t\t\t    attr = changedAttrs && (changedAttrs[rel.keySource] || changedAttrs[rel.key]);\n\n  \t\t\t\t\t// Update a relation if its value differs from this model's attributes, or it's been explicitly nullified.\n  \t\t\t\t\t// Which can also happen before the originally intended related model has been found (`val` is null).\n  \t\t\t\t\tif (rel.related !== value || value === null && attr === null) {\n  \t\t\t\t\t\tthis.trigger('relational:change:' + rel.key, this, value, options || {});\n  \t\t\t\t\t}\n  \t\t\t\t}\n\n  \t\t\t\t// Explicitly clear 'keySource', to prevent a leaky abstraction if 'keySource' differs from 'key'.\n  \t\t\t\tif (rel.keySource !== rel.key) {\n  \t\t\t\t\tdelete this.attributes[rel.keySource];\n  \t\t\t\t}\n  \t\t\t}, this);\n  \t\t}\n  \t},\n\n  \t/**\n    * Either add to the queue (if we're not initialized yet), or execute right away.\n    */\n  \tqueue: function queue(func) {\n  \t\tthis._queue.add(func);\n  \t},\n\n  \t/**\n    * Process _queue\n    */\n  \tprocessQueue: function processQueue() {\n  \t\tif (this._isInitialized && !this._deferProcessing && this._queue.isBlocked()) {\n  \t\t\tthis._queue.unblock();\n  \t\t}\n  \t},\n\n  \t/**\n    * Get a specific relation.\n    * @param {string} attr The relation key to look for.\n    * @return {Backbone.Relation} An instance of 'Backbone.Relation', if a relation was found for 'attr', or null.\n    */\n  \tgetRelation: function getRelation(attr) {\n  \t\treturn this._relations[attr];\n  \t},\n\n  \t/**\n    * Get all of the created relations.\n    * @return {Backbone.Relation[]}\n    */\n  \tgetRelations: function getRelations() {\n  \t\treturn _.values(this._relations);\n  \t},\n\n  \t/**\n    * Get a list of ids that will be fetched on a call to `getAsync`.\n    * @param {string|Backbone.Relation} attr The relation key to fetch models for.\n    * @param [refresh=false] Add ids for models that are already in the relation, refreshing them?\n    * @return {Array} An array of ids that need to be fetched.\n    */\n  \tgetIdsToFetch: function getIdsToFetch(attr, refresh) {\n  \t\tvar rel = attr instanceof module$1.Relation ? attr : this.getRelation(attr),\n  \t\t    ids = rel ? rel.keyIds && rel.keyIds.slice(0) || (rel.keyId || rel.keyId === 0 ? [rel.keyId] : []) : [];\n\n  \t\t// On `refresh`, add the ids for current models in the relation to `idsToFetch`\n  \t\tif (refresh) {\n  \t\t\tvar models = rel.related && (rel.related.models || [rel.related]);\n  \t\t\t_.each(models, function (model) {\n  \t\t\t\tif (model.id || model.id === 0) {\n  \t\t\t\t\tids.push(model.id);\n  \t\t\t\t}\n  \t\t\t});\n  \t\t}\n\n  \t\treturn ids;\n  \t},\n\n  \t/**\n    * Get related objects. Returns a single promise, which can either resolve immediately (if the related model[s])\n    * are already present locally, or after fetching the contents of the requested attribute.\n    * @param {string} attr The relation key to fetch models for.\n    * @param {Object} [options] Options for 'Backbone.Model.fetch' and 'Backbone.sync'.\n    * @param {Boolean} [options.refresh=false] Fetch existing models from the server as well (in order to update them).\n    * @return {jQuery.Deferred} A jQuery promise object. When resolved, its `done` callback will be called with\n    *  contents of `attr`.\n    */\n  \tgetAsync: function getAsync(attr, options) {\n  \t\t// Set default `options` for fetch\n  \t\toptions = _.extend({ add: true, remove: false, refresh: false }, options);\n\n  \t\tvar dit = this,\n  \t\t    requests = [],\n  \t\t    rel = this.getRelation(attr),\n  \t\t    idsToFetch = rel && this.getIdsToFetch(rel, options.refresh),\n  \t\t    coll = rel.related instanceof module$1.Collection ? rel.related : rel.relatedCollection;\n\n  \t\tif (idsToFetch && idsToFetch.length) {\n  \t\t\tvar models = [],\n  \t\t\t    createdModels = [],\n  \t\t\t    setUrl,\n  \t\t\t    createModels = function createModels() {\n  \t\t\t\t// Find (or create) a model for each one that is to be fetched\n  \t\t\t\tmodels = _.map(idsToFetch, function (id) {\n  \t\t\t\t\tvar model = rel.relatedModel.findModel(id);\n\n  \t\t\t\t\tif (!model) {\n  \t\t\t\t\t\tvar attrs = {};\n  \t\t\t\t\t\tattrs[rel.relatedModel.prototype.idAttribute] = id;\n  \t\t\t\t\t\tmodel = rel.relatedModel.findOrCreate(attrs, options);\n  \t\t\t\t\t\tcreatedModels.push(model);\n  \t\t\t\t\t}\n\n  \t\t\t\t\treturn model;\n  \t\t\t\t}, this);\n  \t\t\t};\n\n  \t\t\t// Try if the 'collection' can provide a url to fetch a set of models in one request.\n  \t\t\t// This assumes that when 'module.Collection.url' is a function, it can handle building of set urls.\n  \t\t\t// To make sure it can, test if the url we got by supplying a list of models to fetch is different from\n  \t\t\t// the one supplied for the default fetch action (without args to 'url').\n  \t\t\tif (coll instanceof module$1.Collection && _.isFunction(coll.url)) {\n  \t\t\t\tvar defaultUrl = coll.url();\n  \t\t\t\tsetUrl = coll.url(idsToFetch);\n\n  \t\t\t\tif (setUrl === defaultUrl) {\n  \t\t\t\t\tcreateModels();\n  \t\t\t\t\tsetUrl = coll.url(models);\n\n  \t\t\t\t\tif (setUrl === defaultUrl) {\n  \t\t\t\t\t\tsetUrl = null;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n\n  \t\t\tif (setUrl) {\n  \t\t\t\t// Do a single request to fetch all models\n  \t\t\t\tvar opts = _.defaults({\n  \t\t\t\t\terror: function error() {\n  \t\t\t\t\t\t_.each(createdModels, function (model) {\n  \t\t\t\t\t\t\tmodel.trigger('destroy', model, model.collection, options);\n  \t\t\t\t\t\t});\n\n  \t\t\t\t\t\toptions.error && options.error.apply(models, arguments);\n  \t\t\t\t\t},\n  \t\t\t\t\turl: setUrl\n  \t\t\t\t}, options);\n\n  \t\t\t\trequests = [coll.fetch(opts)];\n  \t\t\t} else {\n  \t\t\t\t// Make a request per model to fetch\n  \t\t\t\tif (!models.length) {\n  \t\t\t\t\tcreateModels();\n  \t\t\t\t}\n\n  \t\t\t\trequests = _.map(models, function (model) {\n  \t\t\t\t\tvar opts = _.defaults({\n  \t\t\t\t\t\terror: function error() {\n  \t\t\t\t\t\t\tif (_.contains(createdModels, model)) {\n  \t\t\t\t\t\t\t\tmodel.trigger('destroy', model, model.collection, options);\n  \t\t\t\t\t\t\t}\n  \t\t\t\t\t\t\toptions.error && options.error.apply(models, arguments);\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}, options);\n  \t\t\t\t\treturn model.fetch(opts);\n  \t\t\t\t}, this);\n  \t\t\t}\n  \t\t}\n\n  \t\treturn this.deferArray(requests).then(function () {\n  \t\t\treturn Backbone__default.Model.prototype.get.call(dit, attr);\n  \t\t});\n  \t},\n\n  \tdeferArray: function deferArray(_deferArray) {\n  \t\treturn Backbone__default.$.when.apply(null, _deferArray);\n  \t},\n\n  \tset: function set(key, value, options) {\n  \t\tmodule$1.eventQueue.block();\n\n  \t\t// Duplicate backbone's behavior to allow separate key/value parameters, instead of a single 'attributes' object\n  \t\tvar attributes, result;\n\n  \t\tif (_.isObject(key) || key == null) {\n  \t\t\tattributes = key;\n  \t\t\toptions = value;\n  \t\t} else {\n  \t\t\tattributes = {};\n  \t\t\tattributes[key] = value;\n  \t\t}\n\n  \t\ttry {\n  \t\t\tvar id = this.id,\n  \t\t\t    newId = attributes && this.idAttribute in attributes && attributes[this.idAttribute];\n\n  \t\t\t// Check if we're not setting a duplicate id before actually calling `set`.\n  \t\t\tmodule$1.store.checkId(this, newId);\n\n  \t\t\tresult = Backbone__default.Model.prototype.set.apply(this, arguments);\n\n  \t\t\t// Ideal place to set up relations, if this is the first time we're here for this model\n  \t\t\tif (!this._isInitialized && !this.isLocked()) {\n  \t\t\t\tthis.constructor.initializeModelHierarchy();\n\n  \t\t\t\t// Only register models that have an id. A model will be registered when/if it gets an id later on.\n  \t\t\t\tif (newId || newId === 0) {\n  \t\t\t\t\tmodule$1.store.register(this);\n  \t\t\t\t}\n\n  \t\t\t\tthis.initializeRelations(options);\n  \t\t\t}\n  \t\t\t// The store should know about an `id` update asap\n  \t\t\telse if (newId && newId !== id) {\n  \t\t\t\t\tmodule$1.store.update(this);\n  \t\t\t\t}\n\n  \t\t\tif (attributes) {\n  \t\t\t\tthis.updateRelations(attributes, options);\n  \t\t\t}\n  \t\t} finally {\n  \t\t\t// Try to run the global queue holding external events\n  \t\t\tmodule$1.eventQueue.unblock();\n  \t\t}\n\n  \t\treturn result;\n  \t},\n\n  \tclone: function clone() {\n  \t\tvar attributes = _.clone(this.attributes);\n  \t\tif (!_.isUndefined(attributes[this.idAttribute])) {\n  \t\t\tattributes[this.idAttribute] = null;\n  \t\t}\n\n  \t\t_.each(this.getRelations(), function (rel) {\n  \t\t\tdelete attributes[rel.key];\n  \t\t});\n\n  \t\treturn new this.constructor(attributes);\n  \t},\n\n  \t/**\n    * Convert relations to JSON, omits them when required\n    */\n  \ttoJSON: function toJSON(options) {\n  \t\t// If this Model has already been fully serialized in this branch once, return to avoid loops\n  \t\tif (this.isLocked()) {\n  \t\t\treturn this.id;\n  \t\t}\n\n  \t\tthis.acquire();\n  \t\tvar json = Backbone__default.Model.prototype.toJSON.call(this, options);\n\n  \t\tif (this.constructor._superModel && !(this.constructor._subModelTypeAttribute in json)) {\n  \t\t\tjson[this.constructor._subModelTypeAttribute] = this.constructor._subModelTypeValue;\n  \t\t}\n\n  \t\t_.each(this._relations, function (rel) {\n  \t\t\tvar related = json[rel.key],\n  \t\t\t    includeInJSON = rel.options.includeInJSON,\n  \t\t\t    value = null;\n\n  \t\t\tif (includeInJSON === true) {\n  \t\t\t\tif (related && _.isFunction(related.toJSON)) {\n  \t\t\t\t\tvalue = related.toJSON(options);\n  \t\t\t\t}\n  \t\t\t} else if (_.isString(includeInJSON)) {\n  \t\t\t\tif (related instanceof module$1.Collection) {\n  \t\t\t\t\tvalue = related.pluck(includeInJSON);\n  \t\t\t\t} else if (related instanceof Backbone__default.Model) {\n  \t\t\t\t\tvalue = related.get(includeInJSON);\n  \t\t\t\t}\n\n  \t\t\t\t// Add ids for 'unfound' models if includeInJSON is equal to (only) the relatedModel's `idAttribute`\n  \t\t\t\tif (includeInJSON === rel.relatedModel.prototype.idAttribute) {\n  \t\t\t\t\tif (rel instanceof module$1.HasMany) {\n  \t\t\t\t\t\tvalue = value.concat(rel.keyIds);\n  \t\t\t\t\t} else if (rel instanceof module$1.HasOne) {\n  \t\t\t\t\t\tvalue = value || rel.keyId;\n\n  \t\t\t\t\t\tif (!value && !_.isObject(rel.keyContents)) {\n  \t\t\t\t\t\t\tvalue = rel.keyContents || null;\n  \t\t\t\t\t\t}\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t} else if (_.isArray(includeInJSON)) {\n  \t\t\t\tif (related instanceof module$1.Collection) {\n  \t\t\t\t\tvalue = [];\n  \t\t\t\t\trelated.each(function (model) {\n  \t\t\t\t\t\tvar curJson = {};\n  \t\t\t\t\t\t_.each(includeInJSON, function (key) {\n  \t\t\t\t\t\t\tcurJson[key] = model.get(key);\n  \t\t\t\t\t\t});\n  \t\t\t\t\t\tvalue.push(curJson);\n  \t\t\t\t\t});\n  \t\t\t\t} else if (related instanceof Backbone__default.Model) {\n  \t\t\t\t\tvalue = {};\n  \t\t\t\t\t_.each(includeInJSON, function (key) {\n  \t\t\t\t\t\tvalue[key] = related.get(key);\n  \t\t\t\t\t});\n  \t\t\t\t}\n  \t\t\t} else {\n  \t\t\t\tdelete json[rel.key];\n  \t\t\t}\n\n  \t\t\t// In case of `wait: true`, Backbone will simply push whatever's passed into `save` into attributes.\n  \t\t\t// We'll want to get this information into the JSON, even if it doesn't conform to our normal\n  \t\t\t// expectations of what's contained in it (no model/collection for a relation, etc).\n  \t\t\tif (value === null && options && options.wait) {\n  \t\t\t\tvalue = related;\n  \t\t\t}\n\n  \t\t\tif (includeInJSON) {\n  \t\t\t\tjson[rel.keyDestination] = value;\n  \t\t\t}\n\n  \t\t\tif (rel.keyDestination !== rel.key) {\n  \t\t\t\tdelete json[rel.key];\n  \t\t\t}\n  \t\t});\n\n  \t\tthis.release();\n  \t\treturn json;\n  \t}\n  }, {\n  \t/**\n    *\n    * @param superModel\n    * @returns {Backbone.Relational.Model.constructor}\n    */\n  \tsetup: function setup(superModel) {\n  \t\t// We don't want to share a relations array with a parent, as this will cause problems with reverse\n  \t\t// relations. Since `relations` may also be a property or function, only use slice if we have an array.\n  \t\tthis.prototype.relations = (this.prototype.relations || []).slice(0);\n\n  \t\tthis._subModels = {};\n  \t\tthis._superModel = null;\n\n  \t\t// If this model has 'subModelTypes' itself, remember them in the store\n  \t\tif (this.prototype.hasOwnProperty('subModelTypes')) {\n  \t\t\tmodule$1.store.addSubModels(this.prototype.subModelTypes, this);\n  \t\t}\n  \t\t// The 'subModelTypes' property should not be inherited, so reset it.\n  \t\telse {\n  \t\t\t\tthis.prototype.subModelTypes = null;\n  \t\t\t}\n\n  \t\t// Initialize all reverseRelations that belong to this new model.\n  \t\t_.each(this.prototype.relations || [], function (rel) {\n  \t\t\tif (!rel.model) {\n  \t\t\t\trel.model = this;\n  \t\t\t}\n\n  \t\t\tif (rel.reverseRelation && rel.model === this) {\n  \t\t\t\tvar preInitialize = true;\n  \t\t\t\tif (_.isString(rel.relatedModel)) {\n  \t\t\t\t\t/**\n        * The related model might not be defined for two reasons\n        *  1. it is related to itself\n        *  2. it never gets defined, e.g. a typo\n        *  3. the model hasn't been defined yet, but will be later\n        * In neither of these cases do we need to pre-initialize reverse relations.\n        * However, for 3. (which is, to us, indistinguishable from 2.), we do need to attempt\n        * setting up this relation again later, in case the related model is defined later.\n        */\n  \t\t\t\t\tvar relatedModel = module$1.store.getObjectByName(rel.relatedModel);\n  \t\t\t\t\tpreInitialize = relatedModel && relatedModel.prototype instanceof module$1.Model;\n  \t\t\t\t}\n\n  \t\t\t\tif (preInitialize) {\n  \t\t\t\t\tmodule$1.store.initializeRelation(null, rel);\n  \t\t\t\t} else if (_.isString(rel.relatedModel)) {\n  \t\t\t\t\tmodule$1.store.addOrphanRelation(rel);\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}, this);\n\n  \t\treturn this;\n  \t},\n\n  \t/**\n    * Create a 'Backbone.Model' instance based on 'attributes'.\n    * @param {Object} attributes\n    * @param {Object} [options]\n    * @return {Backbone.Model}\n    */\n  \tbuild: function build(attributes, options) {\n  \t\t// 'build' is a possible entrypoint; it's possible no model hierarchy has been determined yet.\n  \t\tthis.initializeModelHierarchy();\n\n  \t\t// Determine what type of (sub)model should be built if applicable.\n  \t\tvar model = this._findSubModelType(this, attributes) || this;\n\n  \t\treturn new model(attributes, options);\n  \t},\n\n  \t/**\n    * Determines what type of (sub)model should be built if applicable.\n    * Looks up the proper subModelType in 'this._subModels', recursing into\n    * types until a match is found.  Returns the applicable 'Backbone.Model'\n    * or null if no match is found.\n    * @param {Backbone.Model} type\n    * @param {Object} attributes\n    * @return {Backbone.Model}\n    */\n  \t_findSubModelType: function _findSubModelType(type, attributes) {\n  \t\tif (type._subModels && type.prototype.subModelTypeAttribute in attributes) {\n  \t\t\tvar subModelTypeAttribute = attributes[type.prototype.subModelTypeAttribute];\n  \t\t\tvar subModelType = type._subModels[subModelTypeAttribute];\n  \t\t\tif (subModelType) {\n  \t\t\t\treturn subModelType;\n  \t\t\t} else {\n  \t\t\t\t// Recurse into subModelTypes to find a match\n  \t\t\t\tfor (subModelTypeAttribute in type._subModels) {\n  \t\t\t\t\tsubModelType = this._findSubModelType(type._subModels[subModelTypeAttribute], attributes);\n  \t\t\t\t\tif (subModelType) {\n  \t\t\t\t\t\treturn subModelType;\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\treturn null;\n  \t},\n\n  \t/**\n    *\n    */\n  \tinitializeModelHierarchy: function initializeModelHierarchy() {\n  \t\t// Inherit any relations that have been defined in the parent model.\n  \t\tthis.inheritRelations();\n\n  \t\t// If we came here through 'build' for a model that has 'subModelTypes' then try to initialize the ones that\n  \t\t// haven't been resolved yet.\n  \t\tif (this.prototype.subModelTypes) {\n  \t\t\tvar resolvedSubModels = _.keys(this._subModels);\n  \t\t\tvar unresolvedSubModels = _.omit(this.prototype.subModelTypes, resolvedSubModels);\n  \t\t\t_.each(unresolvedSubModels, function (subModelTypeName) {\n  \t\t\t\tvar subModelType = module$1.store.getObjectByName(subModelTypeName);\n  \t\t\t\tsubModelType && subModelType.initializeModelHierarchy();\n  \t\t\t});\n  \t\t}\n  \t},\n\n  \tinheritRelations: function inheritRelations() {\n  \t\t// Bail out if we've been here before.\n  \t\tif (!_.isUndefined(this._superModel) && !_.isNull(this._superModel)) {\n  \t\t\treturn;\n  \t\t}\n  \t\t// Try to initialize the _superModel.\n  \t\tmodule$1.store.setupSuperModel(this);\n\n  \t\t// If a superModel has been found, copy relations from the _superModel if they haven't been inherited automatically\n  \t\t// (due to a redefinition of 'relations').\n  \t\tif (this._superModel) {\n  \t\t\t// The _superModel needs a chance to initialize its own inherited relations before we attempt to inherit relations\n  \t\t\t// from the _superModel. You don't want to call 'initializeModelHierarchy' because that could cause sub-models of\n  \t\t\t// this class to inherit their relations before this class has had chance to inherit it's relations.\n  \t\t\tthis._superModel.inheritRelations();\n  \t\t\tif (this._superModel.prototype.relations) {\n  \t\t\t\t// Find relations that exist on the '_superModel', but not yet on this model.\n  \t\t\t\tvar inheritedRelations = _.filter(this._superModel.prototype.relations || [], function (superRel) {\n  \t\t\t\t\treturn !_.any(this.prototype.relations || [], function (rel) {\n  \t\t\t\t\t\treturn superRel.relatedModel === rel.relatedModel && superRel.key === rel.key;\n  \t\t\t\t\t}, this);\n  \t\t\t\t}, this);\n\n  \t\t\t\tthis.prototype.relations = inheritedRelations.concat(this.prototype.relations);\n  \t\t\t}\n  \t\t}\n  \t\t// Otherwise, make sure we don't get here again for this type by making '_superModel' false so we fail the\n  \t\t// isUndefined/isNull check next time.\n  \t\telse {\n  \t\t\t\tthis._superModel = false;\n  \t\t\t}\n  \t},\n\n  \t/**\n    * Find an instance of `this` type in 'Backbone.store'.\n    * A new model is created if no matching model is found, `attributes` is an object, and `options.create` is true.\n    * - If `attributes` is a string or a number, `findOrCreate` will query the `store` and return a model if found.\n    * - If `attributes` is an object and is found in the store, the model will be updated with `attributes` unless `options.merge` is `false`.\n    * @param {Object|String|Number} attributes Either a model's id, or the attributes used to create or update a model.\n    * @param {Object} [options]\n    * @param {Boolean} [options.create=true]\n    * @param {Boolean} [options.merge=true]\n    * @param {Boolean} [options.parse=false]\n    * @return {Backbone.Relational.Model}\n    */\n  \tfindOrCreate: function findOrCreate(attributes, options) {\n  \t\toptions || (options = {});\n  \t\tvar parsedAttributes = _.isObject(attributes) && options.parse && this.prototype.parse ? this.prototype.parse(_.clone(attributes), options) : attributes;\n\n  \t\t// If specified, use a custom `find` function to match up existing models to the given attributes.\n  \t\t// Otherwise, try to find an instance of 'this' model type in the store\n  \t\tvar model = this.findModel(parsedAttributes);\n\n  \t\t// If we found an instance, update it with the data in 'item' (unless 'options.merge' is false).\n  \t\t// If not, create an instance (unless 'options.create' is false).\n  \t\tif (_.isObject(attributes)) {\n  \t\t\tif (model && options.merge !== false) {\n  \t\t\t\t// Make sure `options.collection` and `options.url` doesn't cascade to nested models\n  \t\t\t\tdelete options.collection;\n  \t\t\t\tdelete options.url;\n\n  \t\t\t\tmodel.set(parsedAttributes, options);\n  \t\t\t} else if (!model && options.create !== false) {\n  \t\t\t\tmodel = this.build(parsedAttributes, _.defaults({ parse: false }, options));\n  \t\t\t}\n  \t\t}\n\n  \t\treturn model;\n  \t},\n\n  \t/**\n    * Find an instance of `this` type in 'Backbone.store'.\n    * - If `attributes` is a string or a number, `find` will query the `store` and return a model if found.\n    * - If `attributes` is an object and is found in the store, the model will be updated with `attributes` unless `options.merge` is `false`.\n    * @param {Object|String|Number} attributes Either a model's id, or the attributes used to create or update a model.\n    * @param {Object} [options]\n    * @param {Boolean} [options.merge=true]\n    * @param {Boolean} [options.parse=false]\n    * @return {Backbone.Relational.Model}\n    */\n  \tfind: function find(attributes, options) {\n  \t\toptions || (options = {});\n  \t\toptions.create = false;\n  \t\treturn this.findOrCreate(attributes, options);\n  \t},\n\n  \t/**\n    * A hook to override the matching when updating (or creating) a model.\n    * The default implementation is to look up the model by id in the store.\n    * @param {Object} attributes\n    * @returns {Backbone.Relational.Model}\n    */\n  \tfindModel: function findModel(attributes) {\n  \t\treturn module$1.store.find(this, attributes);\n  \t}\n  });\n\n  /**\n   * Override module.Collection._prepareModel, so objects will be built using the correct type\n   * if the collection.model has subModels.\n   * Attempts to find a model for `attrs` in Backbone.store through `findOrCreate`\n   * (which sets the new properties on it if found), or instantiates a new model.\n   */\n  module$1.Collection.prototype.__prepareModel = module$1.Collection.prototype._prepareModel;\n  module$1.Collection.prototype._prepareModel = function (attrs, options) {\n  \tvar model;\n\n  \tif (attrs instanceof Backbone__default.Model) {\n  \t\tif (!attrs.collection) {\n  \t\t\tattrs.collection = this;\n  \t\t}\n  \t\tmodel = attrs;\n  \t} else {\n  \t\toptions = options ? _.clone(options) : {};\n  \t\toptions.collection = this;\n\n  \t\tif (typeof this.model.findOrCreate !== 'undefined') {\n  \t\t\tmodel = this.model.findOrCreate(attrs, options);\n  \t\t} else {\n  \t\t\tmodel = new this.model(attrs, options);\n  \t\t}\n\n  \t\tif (model && model.validationError) {\n  \t\t\tthis.trigger('invalid', this, attrs, options);\n  \t\t\tmodel = false;\n  \t\t}\n  \t}\n\n  \treturn model;\n  };\n\n  /**\n   * Override module.Collection.set, so we'll create objects from attributes where required,\n   * and update the existing models. Also, trigger 'relational:add'.\n   */\n  var set = module$1.Collection.prototype.__set = module$1.Collection.prototype.set;\n  module$1.Collection.prototype.set = function (models, options) {\n  \t// Short-circuit if this Collection doesn't hold RelationalModels\n  \tif (!(this.model.prototype instanceof module$1.Model)) {\n  \t\treturn set.call(this, models, options);\n  \t}\n\n  \tif (options && options.parse) {\n  \t\tmodels = this.parse(models, options);\n  \t}\n\n  \tvar singular = !_.isArray(models),\n  \t    newModels = [],\n  \t    toAdd = [],\n  \t    model = null;\n\n  \tmodels = singular ? models ? [models] : [] : _.clone(models);\n\n  \t//console.debug( 'calling add on coll=%o; model=%o, options=%o', this, models, options );\n  \tfor (var i = 0; i < models.length; i++) {\n  \t\tmodel = models[i];\n  \t\tif (!(model instanceof Backbone__default.Model)) {\n  \t\t\tmodel = module$1.Collection.prototype._prepareModel.call(this, model, options);\n  \t\t}\n\n  \t\tif (model) {\n  \t\t\ttoAdd.push(model);\n\n  \t\t\tif (!(this.get(model) || this.get(model.cid))) {\n  \t\t\t\tnewModels.push(model);\n  \t\t\t}\n  \t\t\t// If we arrive in `add` while performing a `set` (after a create, so the model gains an `id`),\n  \t\t\t// we may get here before `_onModelEvent` has had the chance to update `_byId`.\n  \t\t\telse if (model.id != null) {\n  \t\t\t\t\tthis._byId[model.id] = model;\n  \t\t\t\t}\n  \t\t}\n  \t}\n\n  \t// Add 'models' in a single batch, so the original add will only be called once (and thus 'sort', etc).\n  \t// If `parse` was specified, the collection and contained models have been parsed now.\n  \ttoAdd = singular ? toAdd.length ? toAdd[0] : null : toAdd;\n  \tvar result = set.call(this, toAdd, _.defaults({ merge: false, parse: false }, options));\n\n  \tfor (i = 0; i < newModels.length; i++) {\n  \t\tmodel = newModels[i];\n  \t\t// Fire a `relational:add` event for any model in `newModels` that has actually been added to the collection.\n  \t\tif (this.get(model) || this.get(model.cid)) {\n  \t\t\tthis.trigger('relational:add', model, this, options);\n  \t\t}\n  \t}\n\n  \treturn result;\n  };\n\n  /**\n   * Override 'Backbone.Collection._removeModels' to trigger 'relational:remove'.\n   */\n  var _removeModels = Backbone__default.Collection.prototype.___removeModels = Backbone__default.Collection.prototype._removeModels;\n  Backbone__default.Collection.prototype._removeModels = function (models, options) {\n  \t// Short-circuit if this Collection doesn't hold RelationalModels\n  \tif (!(this.model.prototype instanceof module$1.Model)) {\n  \t\treturn _removeModels.call(this, models, options);\n  \t}\n\n  \tvar toRemove = [];\n\n  \t//console.debug('calling remove on coll=%o; models=%o, options=%o', this, models, options );\n  \t_.each(models, function (model) {\n  \t\tmodel = this.get(model) || model && this.get(model.cid);\n  \t\tmodel && toRemove.push(model);\n  \t}, this);\n\n  \tvar result = _removeModels.call(this, toRemove, options);\n\n  \t_.each(toRemove, function (model) {\n  \t\tthis.trigger('relational:remove', model, this, options);\n  \t}, this);\n\n  \treturn result;\n  };\n\n  /**\n   * Override 'module.Collection.reset' to trigger 'relational:reset'.\n   */\n  var reset = module$1.Collection.prototype.__reset = module$1.Collection.prototype.reset;\n  module$1.Collection.prototype.reset = function (models, options) {\n  \toptions = _.extend({ merge: true }, options);\n  \tvar result = reset.call(this, models, options);\n\n  \tif (this.model.prototype instanceof module$1.Model) {\n  \t\tthis.trigger('relational:reset', this, options);\n  \t}\n\n  \treturn result;\n  };\n\n  /**\n   * Override 'module.Collection.sort' to trigger 'relational:reset'.\n   */\n  var sort = module$1.Collection.prototype.__sort = module$1.Collection.prototype.sort;\n  module$1.Collection.prototype.sort = function (options) {\n  \tvar result = sort.call(this, options);\n\n  \tif (this.model.prototype instanceof module$1.Model) {\n  \t\tthis.trigger('relational:reset', this, options);\n  \t}\n\n  \treturn result;\n  };\n\n  /**\n   * Override 'module.Collection.trigger' so 'add', 'remove' and 'reset' events are queued until relations\n   * are ready.\n   */\n  var trigger = module$1.Collection.prototype.__trigger = module$1.Collection.prototype.trigger;\n  module$1.Collection.prototype.trigger = function (eventName) {\n  \t// Short-circuit if this Collection doesn't hold RelationalModels\n  \tif (!(this.model.prototype instanceof module$1.Model)) {\n  \t\treturn trigger.apply(this, arguments);\n  \t}\n\n  \tif (eventName === 'add' || eventName === 'remove' || eventName === 'reset' || eventName === 'sort') {\n  \t\tvar dit = this,\n  \t\t    args = arguments;\n\n  \t\tif (_.isObject(args[3])) {\n  \t\t\targs = _.toArray(args);\n  \t\t\t// the fourth argument is the option object.\n  \t\t\t// we need to clone it, as it could be modified while we wait on the eventQueue to be unblocked\n  \t\t\targs[3] = _.clone(args[3]);\n  \t\t}\n\n  \t\tmodule$1.eventQueue.add(function () {\n  \t\t\ttrigger.apply(dit, args);\n  \t\t});\n  \t} else {\n  \t\ttrigger.apply(this, arguments);\n  \t}\n\n  \treturn this;\n  };\n\n  // Override .extend() to automatically call .setup()\n  module$1.Model.extend = function (protoProps, classProps) {\n  \tvar child = Backbone__default.Model.extend.apply(this, arguments);\n\n  \tchild.setup(this);\n\n  \treturn child;\n  };\n\n  return module$1;\n\n}));\n//# sourceMappingURL=backbone-relational.js.map\n","/**\n * Semaphore mixin; can be used as both binary and counting.\n **/\nexport default {\n\t_permitsAvailable: null,\n\t_permitsUsed: 0,\n\n\tacquire: function() {\n\t\tif ( this._permitsAvailable && this._permitsUsed >= this._permitsAvailable ) {\n\t\t\tthrow new Error( 'Max permits acquired' );\n\t\t} else {\n\t\t\tthis._permitsUsed++;\n\t\t}\n\t},\n\n\trelease: function() {\n\t\tif ( this._permitsUsed === 0 ) {\n\t\t\tthrow new Error( 'All permits released' );\n\t\t} else {\n\t\t\tthis._permitsUsed--;\n\t\t}\n\t},\n\n\tisLocked: function() {\n\t\treturn this._permitsUsed > 0;\n\t},\n\n\tsetAvailablePermits: function( amount ) {\n\t\tif ( this._permitsUsed > amount ) {\n\t\t\tthrow new Error( 'Available permits cannot be less than used permits' );\n\t\t}\n\t\tthis._permitsAvailable = amount;\n\t}\n};\n","import _ from 'underscore';\nimport Semaphore from './semaphore';\n\n/**\n * A BlockingQueue that accumulates items while blocked (via 'block'),\n * and processes them when unblocked (via 'unblock').\n * Process can also be called manually (via 'process').\n */\nconst BlockingQueue = function() {\n\tthis._queue = [];\n};\n\n_.extend( BlockingQueue.prototype, Semaphore, {\n\t_queue: null,\n\n\tadd: function( func ) {\n\t\tif ( this.isBlocked() ) {\n\t\t\tthis._queue.push( func );\n\t\t} else {\n\t\t\tfunc();\n\t\t}\n\t},\n\n\t// Some of the queued events may trigger other blocking events. By\n\t// copying the queue here it allows queued events to process closer to\n\t// the natural order.\n\t//\n\t// queue events [ 'A', 'B', 'C' ]\n\t// A handler of 'B' triggers 'D' and 'E'\n\t// By copying `this._queue` this executes:\n\t// [ 'A', 'B', 'D', 'E', 'C' ]\n\t// The same order the would have executed if they didn't have to be\n\t// delayed and queued.\n\tprocess: function() {\n\t\tvar queue = this._queue;\n\t\tthis._queue = [];\n\t\twhile ( queue && queue.length ) {\n\t\t\tqueue.shift()();\n\t\t}\n\t},\n\n\tblock: function() {\n\t\tthis.acquire();\n\t},\n\n\tunblock: function() {\n\t\tthis.release();\n\t\tif ( !this.isBlocked() ) {\n\t\t\tthis.process();\n\t\t}\n\t},\n\n\tisBlocked: function() {\n\t\treturn this.isLocked();\n\t}\n});\n\nexport default BlockingQueue;\n","import BlockingQueue from './utils/blocking-queue';\n\n/**\n * Global event queue. Accumulates external events ('add:<key>', 'remove:<key>' and 'change:<key>')\n * until the top-level object is fully initialized (see 'Backbone.Relational.Model').\n */\nexport default new BlockingQueue();\n","import {Model} from 'backbone';\n\nexport default Model.extend;\n","import Backbone from 'backbone';\n\nexport default Backbone.Events;\n","import _ from 'underscore';\nimport extend from './extend';\nimport Events from './events';\n\n/**\n * Base object to extend off of. Works similar to how you extend in Backbone\n */\nconst extendableObject = function(...args) {\n  this.initialize.call(this, ...args);\n};\n_.extend(extendableObject.prototype, Events);\nextendableObject.extend = extend;\n\nexport default extendableObject;\n","export default {\n  showWarnings: true\n};\n","import Backbone from 'backbone';\nimport _ from 'underscore';\nimport Semaphore from './utils/semaphore';\nimport BlockingQueue from './utils/blocking-queue';\nimport eventQueue from './event-queue';\nimport BObject from './utils/object';\nimport config from './config';\n\nconst module = config;\n\nmodule.Collection = Backbone.Collection.extend();\n\nmodule.Semaphore = Semaphore;\nmodule.BlockingQueue = BlockingQueue;\nmodule.eventQueue = eventQueue;\n\n/**\n * Backbone.Store keeps track of all created (and destruction of) Backbone.Relational.Model.\n * Handles lookup for relations.\n */\nmodule.Store = BObject.extend({\n\tinitialize() {\n\t\tthis._collections = [];\n\t\tthis._reverseRelations = [];\n\t\tthis._orphanRelations = [];\n\t\tthis._subModels = [];\n\t\tthis._modelScopes = [ window ];\n\t},\n\n\t/**\n\t * Create a new `Relation`.\n\t * @param {Backbone.Relational.Model} [model]\n\t * @param {Object} relation\n\t * @param {Object} [options]\n\t */\n\tinitializeRelation: function( model, relation, options ) {\n\t\tvar type = !_.isString( relation.type ) ? relation.type : module[ relation.type ] || this.getObjectByName( relation.type );\n\t\tif ( type && type.prototype instanceof module.Relation ) {\n\t\t\tvar rel = new type( model, relation, options ); // Also pushes the new Relation into `model._relations`\n\t\t}\n\t\telse {\n\t\t\tmodule.showWarnings && typeof console !== 'undefined' && console.warn( 'Relation=%o; missing or invalid relation type!', relation );\n\t\t}\n\t},\n\n\t/**\n\t * Add a scope for `getObjectByName` to look for model types by name.\n\t * @param {Object} scope\n\t */\n\taddModelScope: function( scope ) {\n\t\tthis._modelScopes.push( scope );\n\t},\n\n\t/**\n\t * Remove a scope.\n\t * @param {Object} scope\n\t */\n\tremoveModelScope: function( scope ) {\n\t\tthis._modelScopes = _.without( this._modelScopes, scope );\n\t},\n\n\t/**\n\t * Add a set of subModelTypes to the store, that can be used to resolve the '_superModel'\n\t * for a model later in 'setupSuperModel'.\n\t *\n\t * @param {Backbone.Relational.Model} subModelTypes\n\t * @param {Backbone.Relational.Model} superModelType\n\t */\n\taddSubModels: function( subModelTypes, superModelType ) {\n\t\tthis._subModels.push({\n\t\t\t'superModelType': superModelType,\n\t\t\t'subModels': subModelTypes\n\t\t});\n\t},\n\n\t/**\n\t * Check if the given modelType is registered as another model's subModel. If so, add it to the super model's\n\t * '_subModels', and set the modelType's '_superModel', '_subModelTypeName', and '_subModelTypeAttribute'.\n\t *\n\t * @param {Backbone.Relational.Model} modelType\n\t */\n\tsetupSuperModel: function( modelType ) {\n\t\t_.find( this._subModels, function( subModelDef ) {\n\t\t\treturn _.filter( subModelDef.subModels || [], function( subModelTypeName, typeValue ) {\n\t\t\t\tvar subModelType = this.getObjectByName( subModelTypeName );\n\n\t\t\t\tif ( modelType === subModelType ) {\n\t\t\t\t\t// Set 'modelType' as a child of the found superModel\n\t\t\t\t\tsubModelDef.superModelType._subModels[ typeValue ] = modelType;\n\n\t\t\t\t\t// Set '_superModel', '_subModelTypeValue', and '_subModelTypeAttribute' on 'modelType'.\n\t\t\t\t\tmodelType._superModel = subModelDef.superModelType;\n\t\t\t\t\tmodelType._subModelTypeValue = typeValue;\n\t\t\t\t\tmodelType._subModelTypeAttribute = subModelDef.superModelType.prototype.subModelTypeAttribute;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}, this ).length;\n\t\t}, this );\n\t},\n\n\t/**\n\t * Add a reverse relation. Is added to the 'relations' property on model's prototype, and to\n\t * existing instances of 'model' in the store as well.\n\t * @param {Object} relation\n\t * @param {Backbone.Relational.Model} relation.model\n\t * @param {String} relation.type\n\t * @param {String} relation.key\n\t * @param {String|Object} relation.relatedModel\n\t */\n\taddReverseRelation: function( relation ) {\n\t\tvar exists = _.any( this._reverseRelations, function( rel ) {\n\t\t\treturn _.all( relation || [], function( val, key ) {\n\t\t\t\treturn val === rel[ key ];\n\t\t\t});\n\t\t});\n\n\t\tif ( !exists && relation.model && relation.type ) {\n\t\t\tthis._reverseRelations.push( relation );\n\t\t\tthis._addRelation( relation.model, relation );\n\t\t\tthis.retroFitRelation( relation );\n\t\t}\n\t},\n\n\t/**\n\t * Deposit a `relation` for which the `relatedModel` can't be resolved at the moment.\n\t *\n\t * @param {Object} relation\n\t */\n\taddOrphanRelation: function( relation ) {\n\t\tvar exists = _.any( this._orphanRelations, function( rel ) {\n\t\t\treturn _.all( relation || [], function( val, key ) {\n\t\t\t\treturn val === rel[ key ];\n\t\t\t});\n\t\t});\n\n\t\tif ( !exists && relation.model && relation.type ) {\n\t\t\tthis._orphanRelations.push( relation );\n\t\t}\n\t},\n\n\t/**\n\t * Try to initialize any `_orphanRelation`s\n\t */\n\tprocessOrphanRelations: function() {\n\t\t// Make sure to operate on a copy since we're removing while iterating\n\t\t_.each( this._orphanRelations.slice( 0 ), function( rel ) {\n\t\t\tvar relatedModel = module.store.getObjectByName( rel.relatedModel );\n\t\t\tif ( relatedModel ) {\n\t\t\t\tthis.initializeRelation( null, rel );\n\t\t\t\tthis._orphanRelations = _.without( this._orphanRelations, rel );\n\t\t\t}\n\t\t}, this );\n\t},\n\n\t/**\n\t *\n\t * @param {Backbone.Relational.Model.constructor} type\n\t * @param {Object} relation\n\t * @private\n\t */\n\t_addRelation: function( type, relation ) {\n\t\tif ( !type.prototype.relations ) {\n\t\t\ttype.prototype.relations = [];\n\t\t}\n\t\ttype.prototype.relations.push( relation );\n\n\t\t_.each( type._subModels || [], function( subModel ) {\n\t\t\tthis._addRelation( subModel, relation );\n\t\t}, this );\n\t},\n\n\t/**\n\t * Add a 'relation' to all existing instances of 'relation.model' in the store\n\t * @param {Object} relation\n\t */\n\tretroFitRelation: function( relation ) {\n\t\tvar coll = this.getCollection( relation.model, false );\n\t\tcoll && coll.each( function( model ) {\n\t\t\tif ( !( model instanceof relation.model ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar rel = new relation.type( model, relation );\n\t\t}, this );\n\t},\n\n\t/**\n\t * Find the Store's collection for a certain type of model.\n\t * @param {Backbone.Relational.Model} type\n\t * @param {Boolean} [create=true] Should a collection be created if none is found?\n\t * @return {module.Collection} A collection if found (or applicable for 'model'), or null\n\t */\n\tgetCollection: function( type, create ) {\n\t\tif ( type instanceof module.Model ) {\n\t\t\ttype = type.constructor;\n\t\t}\n\n\t\tvar rootModel = type;\n\t\twhile ( rootModel._superModel ) {\n\t\t\trootModel = rootModel._superModel;\n\t\t}\n\n\t\tvar coll = _.find( this._collections, function( item ) {\n\t\t\treturn item.model === rootModel;\n\t\t});\n\n\t\tif ( !coll && create !== false ) {\n\t\t\tcoll = this._createCollection( rootModel );\n\t\t}\n\n\t\treturn coll;\n\t},\n\n\t/**\n\t * Find a model type on one of the modelScopes by name. Names are split on dots.\n\t * @param {String} name\n\t * @return {Object}\n\t */\n\tgetObjectByName: function( name ) {\n\t\tvar parts = name.split( '.' ),\n\t\t\ttype = null;\n\n\t\t_.find( this._modelScopes, function( scope ) {\n\t\t\ttype = _.reduce( parts || [], function( memo, val ) {\n\t\t\t\treturn memo ? memo[ val ] : undefined;\n\t\t\t}, scope );\n\n\t\t\tif ( type && type !== scope ) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}, this );\n\n\t\treturn type;\n\t},\n\n\t_createCollection: function( type ) {\n\t\tvar coll;\n\n\t\t// If 'type' is an instance, take its constructor\n\t\tif ( type instanceof module.Model ) {\n\t\t\ttype = type.constructor;\n\t\t}\n\n\t\t// Type should inherit from Backbone.Relational.Model.\n\t\tif ( type.prototype instanceof module.Model ) {\n\t\t\tcoll = new module.Collection();\n\t\t\tcoll.model = type;\n\n\t\t\tthis._collections.push( coll );\n\t\t}\n\n\t\treturn coll;\n\t},\n\n\t/**\n\t * Find the attribute that is to be used as the `id` on a given object\n\t * @param type\n\t * @param {String|Number|Object|Backbone.Relational.Model} item\n\t * @return {String|Number}\n\t */\n\tresolveIdForItem: function( type, item ) {\n\t\tvar id = _.isString( item ) || _.isNumber( item ) ? item : null;\n\n\t\tif ( id === null ) {\n\t\t\tif ( item instanceof module.Model ) {\n\t\t\t\tid = item.id;\n\t\t\t}\n\t\t\telse if ( _.isObject( item ) ) {\n\t\t\t\tid = item[ type.prototype.idAttribute ];\n\t\t\t}\n\t\t}\n\n\t\t// Make all falsy values `null` (except for 0, which could be an id.. see '/issues/179')\n\t\tif ( !id && id !== 0 ) {\n\t\t\tid = null;\n\t\t}\n\n\t\treturn id;\n\t},\n\n\t/**\n\t * Find a specific model of a certain `type` in the store\n\t * @param type\n\t * @param {String|Number|Object|Backbone.Relational.Model} item\n\t */\n\tfind: function( type, item ) {\n\t\tvar id = this.resolveIdForItem( type, item ),\n\t\t\tcoll = this.getCollection( type );\n\n\t\t// Because the found object could be of any of the type's superModel\n\t\t// types, only return it if it's actually of the type asked for.\n\t\tif ( coll ) {\n\t\t\tvar obj = coll.get( id );\n\n\t\t\tif ( obj instanceof type ) {\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t},\n\n\t/**\n\t * Add a 'model' to its appropriate collection. Retain the original contents of 'model.collection'.\n\t * @param {Backbone.Relational.Model} model\n\t */\n\tregister: function( model ) {\n\t\tvar coll = this.getCollection( model );\n\n\t\tif ( coll ) {\n\t\t\tvar modelColl = model.collection;\n\t\t\tcoll.add( model );\n\t\t\tmodel.collection = modelColl;\n\t\t}\n\t},\n\n\t/**\n\t * Check if the given model may use the given `id`\n\t * @param model\n\t * @param [id]\n\t */\n\tcheckId: function( model, id ) {\n\t\tvar coll = this.getCollection( model ),\n\t\t\tduplicate = coll && coll.get( id );\n\n\t\tif ( duplicate && model !== duplicate ) {\n\t\t\tif ( module.showWarnings && typeof console !== 'undefined' ) {\n\t\t\t\tconsole.warn( 'Duplicate id! Old RelationalModel=%o, new RelationalModel=%o', duplicate, model );\n\t\t\t}\n\n\t\t\tthrow new Error( \"Cannot instantiate more than one Backbone.Relational.Model with the same id per type!\" );\n\t\t}\n\t},\n\n\t/**\n\t * Explicitly update a model's id in its store collection\n\t * @param {Backbone.Relational.Model} model\n\t */\n\tupdate: function( model ) {\n\t\tvar coll = this.getCollection( model );\n\n\t\t// Register a model if it isn't yet (which happens if it was created without an id).\n\t\tif ( !coll.contains( model ) ) {\n\t\t\tthis.register( model );\n\t\t}\n\n\t\t// This triggers updating the lookup indices kept in a collection\n\t\tcoll._onModelEvent( 'change:' + model.idAttribute, model, coll );\n\n\t\t// Trigger an event on model so related models (having the model's new id in their keyContents) can add it.\n\t\tmodel.trigger( 'relational:change:id', model, coll );\n\t},\n\n\t/**\n\t * Unregister from the store: a specific model, a collection, or a model type.\n\t * @param {Backbone.Relational.Model|Backbone.Relational.Model.constructor|module.Collection} type\n\t */\n\tunregister: function( type ) {\n\t\tvar coll,\n\t\t\tmodels;\n\n\t\tif ( type instanceof Backbone.Model ) {\n\t\t\tcoll = this.getCollection( type );\n\t\t\tmodels = [ type ];\n\t\t}\n\t\telse if ( type instanceof module.Collection ) {\n\t\t\tcoll = this.getCollection( type.model );\n\t\t\tmodels = _.clone( type.models );\n\t\t}\n\t\telse {\n\t\t\tcoll = this.getCollection( type );\n\t\t\tmodels = _.clone( coll.models );\n\t\t}\n\n\t\t_.each( models, function( model ) {\n\t\t\tthis.stopListening( model );\n\t\t\t_.invoke( model.getRelations(), 'stopListening' );\n\t\t}, this );\n\n\n\t\t// If we've unregistered an entire store collection, reset the collection (which is much faster).\n\t\t// Otherwise, remove each model one by one.\n\t\tif ( _.contains( this._collections, type ) ) {\n\t\t\tcoll.reset( [] );\n\t\t}\n\t\telse {\n\t\t\t_.each( models, function( model ) {\n\t\t\t\tif ( coll.get( model ) ) {\n\t\t\t\t\tcoll.remove( model );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcoll.trigger( 'relational:remove', model, coll );\n\t\t\t\t}\n\t\t\t}, this );\n\t\t}\n\t},\n\n\t/**\n\t * Reset the `store` to it's original state. The `reverseRelations` are kept though, since attempting to\n\t * re-initialize these on models would lead to a large amount of warnings.\n\t */\n\treset: function() {\n\t\tthis.stopListening();\n\n\t\t// Unregister each collection to remove event listeners\n\t\t_.each( this._collections, function( coll ) {\n\t\t\tthis.unregister( coll );\n\t\t}, this );\n\n\t\tthis._collections = [];\n\t\tthis._subModels = [];\n\t\tthis._modelScopes = [ window ];\n\t}\n});\n\nmodule.store = new module.Store();\n\n/**\n * The main Relation class, from which 'HasOne' and 'HasMany' inherit. Internally, 'relational:<key>' events\n * are used to regulate addition and removal of models from relations.\n *\n * @param {Backbone.Relational.Model} [instance] Model that this relation is created for. If no model is supplied,\n *      Relation just tries to instantiate it's `reverseRelation` if specified, and bails out after that.\n * @param {Object} options\n * @param {string} options.key\n * @param {Backbone.Relational.Model.constructor} options.relatedModel\n * @param {Boolean|String} [options.includeInJSON=true] Serialize the given attribute for related model(s)' in toJSON, or just their ids.\n * @param {Boolean} [options.createModels=true] Create objects from the contents of keys if the object is not found in Backbone.store.\n * @param {Object} [options.reverseRelation] Specify a bi-directional relation. If provided, Relation will reciprocate\n *    the relation to the 'relatedModel'. Required and optional properties match 'options', except that it also needs\n *    {Backbone.Relation|String} type ('HasOne' or 'HasMany').\n * @param {Object} opts\n */\nmodule.Relation = BObject.extend(Semaphore).extend({\n\toptions: {\n\t\tcreateModels: true,\n\t\tincludeInJSON: true,\n\t\tisAutoRelation: false,\n\t\tautoFetch: false,\n\t\tparse: false\n\t},\n\n\tinstance: null,\n\tkey: null,\n\tkeyContents: null,\n\trelatedModel: null,\n\trelatedCollection: null,\n\treverseRelation: null,\n\trelated: null,\n\n\tconstructor(instance, options, opts) {\n\t\tthis.instance = instance;\n\t\t// Make sure 'options' is sane, and fill with defaults from subclasses and this object's prototype\n\t\toptions = _.isObject( options ) ? options : {};\n\t\tthis.reverseRelation = _.defaults( options.reverseRelation || {}, this.options.reverseRelation );\n\t\tthis.options = _.defaults( options, this.options, module.Relation.prototype.options );\n\n\t\tthis.reverseRelation.type = !_.isString( this.reverseRelation.type ) ? this.reverseRelation.type :\n\t\t\tmodule[ this.reverseRelation.type ] || module.store.getObjectByName( this.reverseRelation.type );\n\n\t\tthis.key = this.options.key;\n\t\tthis.keySource = this.options.keySource || this.key;\n\t\tthis.keyDestination = this.options.keyDestination || this.keySource || this.key;\n\n\t\tthis.model = this.options.model || this.instance.constructor;\n\n\t\tthis.relatedModel = this.options.relatedModel;\n\n\t\tif(_.isUndefined(this.relatedModel)){\n\t\t\tthis.relatedModel = this.model;\n\t\t}\n\n\t\tif ( _.isFunction( this.relatedModel ) && !( this.relatedModel.prototype instanceof module.Model ) ) {\n\t\t\tthis.relatedModel = _.result( this, 'relatedModel' );\n\t\t}\n\t\tif ( _.isString( this.relatedModel ) ) {\n\t\t\tthis.relatedModel = module.store.getObjectByName( this.relatedModel );\n\t\t}\n\n\t\tif ( !this.checkPreconditions() ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Add the reverse relation on 'relatedModel' to the store's reverseRelations\n\t\tif ( !this.options.isAutoRelation && this.reverseRelation.type && this.reverseRelation.key ) {\n\t\t\tmodule.store.addReverseRelation( _.defaults( {\n\t\t\t\t\tisAutoRelation: true,\n\t\t\t\t\tmodel: this.relatedModel,\n\t\t\t\t\trelatedModel: this.model,\n\t\t\t\t\treverseRelation: this.options // current relation is the 'reverseRelation' for its own reverseRelation\n\t\t\t\t},\n\t\t\t\tthis.reverseRelation // Take further properties from this.reverseRelation (type, key, etc.)\n\t\t\t) );\n\t\t}\n\n\t\tif ( instance ) {\n\t\t\tvar contentKey = this.keySource;\n\t\t\tif ( contentKey !== this.key && _.isObject( this.instance.get( this.key ) ) ) {\n\t\t\t\tcontentKey = this.key;\n\t\t\t}\n\n\t\t\tthis.setKeyContents( this.instance.get( contentKey ) );\n\t\t\tthis.relatedCollection = module.store.getCollection( this.relatedModel );\n\n\t\t\t// Explicitly clear 'keySource', to prevent a leaky abstraction if 'keySource' differs from 'key'.\n\t\t\tif ( this.keySource !== this.key ) {\n\t\t\t\tdelete this.instance.attributes[ this.keySource ];\n\t\t\t}\n\n\t\t\t// Add this Relation to instance._relations\n\t\t\tthis.instance._relations[ this.key ] = this;\n\n\t\t\tthis.initialize( opts );\n\n\t\t\tif ( this.options.autoFetch ) {\n\t\t\t\tthis.instance.getAsync( this.key, _.isObject( this.options.autoFetch ) ? this.options.autoFetch : {} );\n\t\t\t}\n\n\t\t\t// When 'relatedModel' are created or destroyed, check if it affects this relation.\n\t\t\tthis.listenTo( this.instance, 'destroy', this.destroy )\n\t\t\t\t.listenTo( this.relatedCollection, 'relational:add relational:change:id', this.tryAddRelated )\n\t\t\t\t.listenTo( this.relatedCollection, 'relational:remove', this.removeRelated );\n\t\t}\n\t},\n\n\t/**\n\t * Check several pre-conditions.\n\t * @return {Boolean} True if pre-conditions are satisfied, false if they're not.\n\t */\n\tcheckPreconditions: function() {\n\t\tvar i = this.instance,\n\t\t\tk = this.key,\n\t\t\tm = this.model,\n\t\t\trm = this.relatedModel,\n\t\t\twarn = module.showWarnings && typeof console !== 'undefined';\n\n\t\tif ( !m || !k || !rm ) {\n\t\t\twarn && console.warn( 'Relation=%o: missing model, key or relatedModel (%o, %o, %o).', this, m, k, rm );\n\t\t\treturn false;\n\t\t}\n\t\t// Check if the type in 'model' inherits from Backbone.Relational.Model\n\t\tif ( !( m.prototype instanceof module.Model ) ) {\n\t\t\twarn && console.warn( 'Relation=%o: model does not inherit from Backbone.Relational.Model (%o).', this, i );\n\t\t\treturn false;\n\t\t}\n\t\t// Check if the type in 'relatedModel' inherits from Backbone.Relational.Model\n\t\tif ( !( rm.prototype instanceof module.Model ) ) {\n\t\t\twarn && console.warn( 'Relation=%o: relatedModel does not inherit from Backbone.Relational.Model (%o).', this, rm );\n\t\t\treturn false;\n\t\t}\n\t\t// Check if this is not a HasMany, and the reverse relation is HasMany as well\n\t\tif ( this instanceof module.HasMany && this.reverseRelation.type === module.HasMany ) {\n\t\t\twarn && console.warn( 'Relation=%o: relation is a HasMany, and the reverseRelation is HasMany as well.', this );\n\t\t\treturn false;\n\t\t}\n\t\t// Check if we're not attempting to create a relationship on a `key` that's already used.\n\t\tif ( i && _.keys( i._relations ).length ) {\n\t\t\tvar existing = _.find( i._relations, function( rel ) {\n\t\t\t\treturn rel.key === k;\n\t\t\t}, this );\n\n\t\t\tif ( existing ) {\n\t\t\t\twarn && console.warn( 'Cannot create relation=%o on %o for model=%o: already taken by relation=%o.',\n\t\t\t\t\tthis, k, i, existing );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t/**\n\t * Set the related model(s) for this relation\n\t * @param {Backbone.Model|module.Collection} related\n\t */\n\tsetRelated: function( related ) {\n\t\tthis.related = related;\n\t\tthis.instance.attributes[ this.key ] = related;\n\t},\n\n\t/**\n\t * Determine if a relation (on a different RelationalModel) is the reverse\n\t * relation of the current one.\n\t * @param {Backbone.Relation} relation\n\t * @return {Boolean}\n\t */\n\t_isReverseRelation: function( relation ) {\n\t\treturn relation.instance instanceof this.relatedModel && this.reverseRelation.key === relation.key &&\n\t\t\tthis.key === relation.reverseRelation.key;\n\t},\n\n\t/**\n\t * Get the reverse relations (pointing back to 'this.key' on 'this.instance') for the currently related model(s).\n\t * @param {Backbone.Relational.Model} [model] Get the reverse relations for a specific model.\n\t *    If not specified, 'this.related' is used.\n\t * @return {Backbone.Relation[]}\n\t */\n\tgetReverseRelations: function( model ) {\n\t\tvar reverseRelations = [];\n\t\t// Iterate over 'model', 'this.related.models' (if this.related is a module.Collection), or wrap 'this.related' in an array.\n\t\tvar models = !_.isUndefined( model ) ? [ model ] : this.related && ( this.related.models || [ this.related ] ),\n\t\t\trelations = null,\n\t\t\trelation = null;\n\n\t\tfor( var i = 0; i < ( models || [] ).length; i++ ) {\n\t\t\trelations = models[ i ].getRelations() || [];\n\n\t\t\tfor( var j = 0; j < relations.length; j++ ) {\n\t\t\t\trelation = relations[ j ];\n\n\n\t\t\t\tif ( this._isReverseRelation( relation ) ) {\n\t\t\t\t\treverseRelations.push( relation );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn reverseRelations;\n\t},\n\n\t/**\n\t * When `this.instance` is destroyed, cleanup our relations.\n\t * Get reverse relation, call removeRelated on each.\n\t */\n\tdestroy: function() {\n\t\tthis.stopListening();\n\n\t\tif ( this instanceof module.HasOne ) {\n\t\t\tthis.setRelated( null );\n\t\t}\n\t\telse if ( this instanceof module.HasMany ) {\n\t\t\tthis.setRelated( this._prepareCollection() );\n\t\t}\n\n\t\t_.each( this.getReverseRelations(), function( relation ) {\n\t\t\trelation.removeRelated( this.instance );\n\t\t}, this );\n\t}\n});\n\nmodule.HasOne = module.Relation.extend({\n\toptions: {\n\t\treverseRelation: { type: 'HasMany' }\n\t},\n\n\tinitialize: function( opts ) {\n\t\tthis.listenTo( this.instance, 'relational:change:' + this.key, this.onChange );\n\n\t\tvar related = this.findRelated( opts );\n\t\tthis.setRelated( related );\n\n\t\t// Notify new 'related' object of the new relation.\n\t\t_.each( this.getReverseRelations(), function( relation ) {\n\t\t\trelation.addRelated( this.instance, opts );\n\t\t}, this );\n\t},\n\n\t/**\n\t * Find related Models.\n\t * @param {Object} [options]\n\t * @return {Backbone.Model}\n\t */\n\tfindRelated: function( options ) {\n\t\tvar related = null;\n\n\t\toptions = _.defaults( { parse: this.options.parse }, options );\n\n\t\tif ( this.keyContents instanceof this.relatedModel ) {\n\t\t\trelated = this.keyContents;\n\t\t}\n\t\telse if ( this.keyContents || this.keyContents === 0 ) { // since 0 can be a valid `id` as well\n\t\t\tvar opts = _.defaults( { create: this.options.createModels }, options );\n\t\t\trelated = this.relatedModel.findOrCreate( this.keyContents, opts );\n\t\t}\n\n\t\t// Nullify `keyId` if we have a related model; in case it was already part of the relation\n\t\tif ( related ) {\n\t\t\tthis.keyId = null;\n\t\t}\n\n\t\treturn related;\n\t},\n\n\t/**\n\t * Normalize and reduce `keyContents` to an `id`, for easier comparison\n\t * @param {String|Number|Backbone.Model} keyContents\n\t */\n\tsetKeyContents: function( keyContents ) {\n\t\tthis.keyContents = keyContents;\n\t\tthis.keyId = module.store.resolveIdForItem( this.relatedModel, this.keyContents );\n\t},\n\n\t/**\n\t * Event handler for `change:<key>`.\n\t * If the key is changed, notify old & new reverse relations and initialize the new relation.\n\t */\n\tonChange: function( model, attr, options ) {\n\t\t// Don't accept recursive calls to onChange (like onChange->findRelated->findOrCreate->initializeRelations->addRelated->onChange)\n\t\tif ( this.isLocked() ) {\n\t\t\treturn;\n\t\t}\n\t\tthis.acquire();\n\t\toptions = options ? _.clone( options ) : {};\n\n\t\t// 'options.__related' is set by 'addRelated'/'removeRelated'. If it is set, the change\n\t\t// is the result of a call from a relation. If it's not, the change is the result of\n\t\t// a 'set' call on this.instance.\n\t\tvar changed = _.isUndefined( options.__related ),\n\t\t\toldRelated = changed ? this.related : options.__related;\n\n\t\tif ( changed ) {\n\t\t\tthis.setKeyContents( attr );\n\t\t\tvar related = this.findRelated( options );\n\t\t\tthis.setRelated( related );\n\t\t}\n\n\t\t// Notify old 'related' object of the terminated relation\n\t\tif ( oldRelated && this.related !== oldRelated ) {\n\t\t\t_.each( this.getReverseRelations( oldRelated ), function( relation ) {\n\t\t\t\trelation.removeRelated( this.instance, null, options );\n\t\t\t}, this );\n\t\t}\n\n\t\t// Notify new 'related' object of the new relation. Note we do re-apply even if this.related is oldRelated;\n\t\t// that can be necessary for bi-directional relations if 'this.instance' was created after 'this.related'.\n\t\t// In that case, 'this.instance' will already know 'this.related', but the reverse might not exist yet.\n\t\t_.each( this.getReverseRelations(), function( relation ) {\n\t\t\trelation.addRelated( this.instance, options );\n\t\t}, this );\n\n\t\t// Fire the 'change:<key>' event if 'related' was updated\n\t\tif ( !options.silent && this.related !== oldRelated ) {\n\t\t\tvar dit = this;\n\t\t\tthis.changed = true;\n\t\t\tmodule.eventQueue.add( function() {\n\t\t\t\tdit.instance.trigger( 'change:' + dit.key, dit.instance, dit.related, options, true );\n\t\t\t\tdit.changed = false;\n\t\t\t});\n\t\t}\n\t\tthis.release();\n\t},\n\n\t/**\n\t * If a new 'this.relatedModel' appears in the 'store', try to match it to the last set 'keyContents'\n\t */\n\ttryAddRelated: function( model, coll, options ) {\n\t\tif ( ( this.keyId || this.keyId === 0 ) && model.id === this.keyId ) { // since 0 can be a valid `id` as well\n\t\t\tthis.addRelated( model, options );\n\t\t\tthis.keyId = null;\n\t\t}\n\t},\n\n\taddRelated: function( model, options ) {\n\t\t// Allow 'model' to set up its relations before proceeding.\n\t\t// (which can result in a call to 'addRelated' from a relation of 'model')\n\t\tvar dit = this;\n\t\tmodel.queue( function() {\n\t\t\tif ( model !== dit.related ) {\n\t\t\t\tvar oldRelated = dit.related || null;\n\t\t\t\tdit.setRelated( model );\n\t\t\t\tdit.onChange( dit.instance, model, _.defaults( { __related: oldRelated }, options ) );\n\t\t\t}\n\t\t});\n\t},\n\n\tremoveRelated: function( model, coll, options ) {\n\t\tif ( !this.related ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( model === this.related ) {\n\t\t\tvar oldRelated = this.related || null;\n\t\t\tthis.setRelated( null );\n\t\t\tthis.onChange( this.instance, model, _.defaults( { __related: oldRelated }, options ) );\n\t\t}\n\t}\n});\n\nmodule.HasMany = module.Relation.extend({\n\tcollectionType: null,\n\n\toptions: {\n\t\treverseRelation: { type: 'HasOne' },\n\t\tcollectionType: module.Collection,\n\t\tcollectionKey: true,\n\t\tcollectionOptions: {}\n\t},\n\n\tinitialize: function( opts ) {\n\t\tthis.listenTo( this.instance, 'relational:change:' + this.key, this.onChange );\n\n\t\t// Handle a custom 'collectionType'\n\t\tthis.collectionType = this.options.collectionType;\n\t\tif ( _.isFunction( this.collectionType ) && this.collectionType !== module.Collection && !( this.collectionType.prototype instanceof module.Collection ) ) {\n\t\t\tthis.collectionType = _.result( this, 'collectionType' );\n\t\t}\n\t\tif ( _.isString( this.collectionType ) ) {\n\t\t\tthis.collectionType = module.store.getObjectByName( this.collectionType );\n\t\t}\n\t\tif ( this.collectionType !== module.Collection && !( this.collectionType.prototype instanceof module.Collection ) ) {\n\t\t\tthrow new Error( '`collectionType` must inherit from module.Collection' );\n\t\t}\n\n\t\tvar related = this.findRelated( opts );\n\t\tthis.setRelated( related );\n\t},\n\n\t/**\n\t * Bind events and setup collectionKeys for a collection that is to be used as the backing store for a HasMany.\n\t * If no 'collection' is supplied, a new collection will be created of the specified 'collectionType' option.\n\t * @param {module.Collection} [collection]\n\t * @return {module.Collection}\n\t */\n\t_prepareCollection: function( collection ) {\n\t\tif ( this.related ) {\n\t\t\tthis.stopListening( this.related );\n\t\t}\n\n\t\tif ( !collection || !( collection instanceof module.Collection ) ) {\n\t\t\tvar options = _.isFunction( this.options.collectionOptions ) ?\n\t\t\t\tthis.options.collectionOptions( this.instance ) : this.options.collectionOptions;\n\n\t\t\tcollection = new this.collectionType( null, options );\n\t\t}\n\n\t\tcollection.model = this.relatedModel;\n\n\t\tif ( this.options.collectionKey ) {\n\t\t\tvar key = this.options.collectionKey === true ? this.options.reverseRelation.key : this.options.collectionKey;\n\n\t\t\tif ( collection[ key ] && collection[ key ] !== this.instance ) {\n\t\t\t\tif ( module.showWarnings && typeof console !== 'undefined' ) {\n\t\t\t\t\tconsole.warn( 'Relation=%o; collectionKey=%s already exists on collection=%o', this, key, this.options.collectionKey );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( key ) {\n\t\t\t\tcollection[ key ] = this.instance;\n\t\t\t}\n\t\t}\n\n\t\tthis.listenTo( collection, 'relational:add', this.handleAddition )\n\t\t\t.listenTo( collection, 'relational:remove', this.handleRemoval )\n\t\t\t.listenTo( collection, 'relational:reset', this.handleReset );\n\n\t\treturn collection;\n\t},\n\n\t/**\n\t * Find related Models.\n\t * @param {Object} [options]\n\t * @return {module.Collection}\n\t */\n\tfindRelated: function( options ) {\n\t\tvar related = null;\n\n\t\toptions = _.defaults( { parse: this.options.parse }, options );\n\n\t\t// Replace 'this.related' by 'this.keyContents' if it is a module.Collection\n\t\tif ( this.keyContents instanceof module.Collection ) {\n\t\t\tthis._prepareCollection( this.keyContents );\n\t\t\trelated = this.keyContents;\n\t\t}\n\t\t// Otherwise, 'this.keyContents' should be an array of related object ids.\n\t\t// Re-use the current 'this.related' if it is a module.Collection; otherwise, create a new collection.\n\t\telse {\n\t\t\tvar toAdd = [];\n\n\t\t\t_.each( this.keyContents, function( attributes ) {\n\t\t\t\tvar model = null;\n\n\t\t\t\tif ( attributes instanceof this.relatedModel ) {\n\t\t\t\t\tmodel = attributes;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// If `merge` is true, update models here, instead of during update.\n\t\t\t\t\tmodel = ( _.isObject( attributes ) && options.parse && this.relatedModel.prototype.parse ) ?\n\t\t\t\t\t\tthis.relatedModel.prototype.parse( _.clone( attributes ), options ) : attributes;\n\t\t\t\t}\n\n\t\t\t\tmodel && toAdd.push( model );\n\t\t\t}, this );\n\n\t\t\tif ( this.related instanceof module.Collection ) {\n\t\t\t\trelated = this.related;\n\t\t\t}\n\t\t\telse {\n\t\t\t\trelated = this._prepareCollection();\n\t\t\t}\n\n\t\t\t// By now, `parse` will already have been executed just above for models if specified.\n\t\t\t// Disable to prevent additional calls.\n\t\t\trelated.set( toAdd, _.defaults( { parse: false }, options ) );\n\t\t}\n\n\t\t// Remove entries from `keyIds` that were already part of the relation (and are thus 'unchanged')\n\t\tthis.keyIds = _.difference( this.keyIds, _.pluck( related.models, 'id' ) );\n\n\t\treturn related;\n\t},\n\n\t/**\n\t * Normalize and reduce `keyContents` to a list of `ids`, for easier comparison\n\t * @param {String|Number|String[]|Number[]|module.Collection} keyContents\n\t */\n\tsetKeyContents: function( keyContents ) {\n\t\tthis.keyContents = keyContents instanceof module.Collection ? keyContents : null;\n\t\tthis.keyIds = [];\n\n\t\tif ( !this.keyContents && ( keyContents || keyContents === 0 ) ) { // since 0 can be a valid `id` as well\n\t\t\t// Handle cases the an API/user supplies just an Object/id instead of an Array\n\t\t\tthis.keyContents = _.isArray( keyContents ) ? keyContents : [ keyContents ];\n\n\t\t\t_.each( this.keyContents, function( item ) {\n\t\t\t\tvar itemId = module.store.resolveIdForItem( this.relatedModel, item );\n\t\t\t\tif ( itemId || itemId === 0 ) {\n\t\t\t\t\tthis.keyIds.push( itemId );\n\t\t\t\t}\n\t\t\t}, this );\n\t\t}\n\t},\n\n\t/**\n\t * Event handler for `change:<key>`.\n\t * If the contents of the key are changed, notify old & new reverse relations and initialize the new relation.\n\t */\n\tonChange: function( model, attr, options ) {\n\t\toptions = options ? _.clone( options ) : {};\n\t\tthis.setKeyContents( attr );\n\t\tthis.changed = false;\n\n\t\tvar related = this.findRelated( options );\n\t\tthis.setRelated( related );\n\n\t\tif ( !options.silent ) {\n\t\t\tvar dit = this;\n\t\t\tmodule.eventQueue.add( function() {\n\t\t\t\t// The `changed` flag can be set in `handleAddition` or `handleRemoval`\n\t\t\t\tif ( dit.changed ) {\n\t\t\t\t\tdit.instance.trigger( 'change:' + dit.key, dit.instance, dit.related, options, true );\n\t\t\t\t\tdit.changed = false;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t * When a model is added to a 'HasMany', trigger 'add' on 'this.instance' and notify reverse relations.\n\t * (should be 'HasOne', must set 'this.instance' as their related).\n\t */\n\thandleAddition: function( model, coll, options ) {\n\t\t//console.debug('handleAddition called; args=%o', arguments);\n\t\toptions = options ? _.clone( options ) : {};\n\t\tthis.changed = true;\n\n\t\t_.each( this.getReverseRelations( model ), function( relation ) {\n\t\t\trelation.addRelated( this.instance, options );\n\t\t}, this );\n\n\t\t// Only trigger 'add' once the newly added model is initialized (so, has its relations set up)\n\t\tvar dit = this;\n\t\t!options.silent && module.eventQueue.add( function() {\n\t\t\tdit.instance.trigger( 'add:' + dit.key, model, dit.related, options );\n\t\t});\n\t},\n\n\t/**\n\t * When a model is removed from a 'HasMany', trigger 'remove' on 'this.instance' and notify reverse relations.\n\t * (should be 'HasOne', which should be nullified)\n\t */\n\thandleRemoval: function( model, coll, options ) {\n\t\t//console.debug('handleRemoval called; args=%o', arguments);\n\t\toptions = options ? _.clone( options ) : {};\n\t\tthis.changed = true;\n\n\t\t_.each( this.getReverseRelations( model ), function( relation ) {\n\t\t\trelation.removeRelated( this.instance, null, options );\n\t\t}, this );\n\n\t\tvar dit = this;\n\t\t!options.silent && module.eventQueue.add( function() {\n\t\t\tdit.instance.trigger( 'remove:' + dit.key, model, dit.related, options );\n\t\t});\n\t},\n\n\thandleReset: function( coll, options ) {\n\t\tvar dit = this;\n\t\toptions = options ? _.clone( options ) : {};\n\t\t!options.silent && module.eventQueue.add( function() {\n\t\t\tdit.instance.trigger( 'reset:' + dit.key, dit.related, options );\n\t\t});\n\t},\n\n\ttryAddRelated: function( model, coll, options ) {\n\t\tvar item = _.contains( this.keyIds, model.id );\n\n\t\tif ( item ) {\n\t\t\tthis.addRelated( model, options );\n\t\t\tthis.keyIds = _.without( this.keyIds, model.id );\n\t\t}\n\t},\n\n\taddRelated: function( model, options ) {\n\t\t// Allow 'model' to set up its relations before proceeding.\n\t\t// (which can result in a call to 'addRelated' from a relation of 'model')\n\t\tvar dit = this;\n\t\tmodel.queue( function() {\n\t\t\tif ( dit.related && !dit.related.get( model ) ) {\n\t\t\t\tdit.related.add( model, _.defaults( { parse: false }, options ) );\n\t\t\t}\n\t\t});\n\t},\n\n\tremoveRelated: function( model, coll, options ) {\n\t\tif ( this.related.get( model ) ) {\n\t\t\tthis.related.remove( model, options );\n\t\t}\n\t}\n});\n\n/**\n * A type of Backbone.Model that also maintains relations to other models and collections.\n * New events when compared to the original:\n *  - 'add:<key>' (model, related collection, options)\n *  - 'remove:<key>' (model, related collection, options)\n *  - 'change:<key>' (model, related model or collection, options)\n */\nmodule.Model = Backbone.Model.extend(Semaphore).extend({\n\trelations: null, // Relation descriptions on the prototype\n\t_relations: null, // Relation instances\n\t_isInitialized: false,\n\t_deferProcessing: false,\n\t_queue: null,\n\t_attributeChangeFired: false, // Keeps track of `change` event firing under some conditions (like nested `set`s)\n\n\tsubModelTypeAttribute: 'type',\n\tsubModelTypes: null,\n\n\tconstructor: function( attributes, options ) {\n\t\t// Nasty hack, for cases like 'model.get( <HasMany key> ).add( item )'.\n\t\t// Defer 'processQueue', so that when 'Relation.createModels' is used we trigger 'HasMany'\n\t\t// collection events only after the model is really fully set up.\n\t\t// Example: event for \"p.on( 'add:jobs' )\" -> \"p.get('jobs').add( { company: c.id, person: p.id } )\".\n\t\tif ( options && options.collection ) {\n\t\t\tvar dit = this,\n\t\t\t\tcollection = this.collection = options.collection;\n\n\t\t\t// Prevent `collection` from cascading down to nested models; they shouldn't go into this `if` clause.\n\t\t\tdelete options.collection;\n\n\t\t\tthis._deferProcessing = true;\n\n\t\t\tvar processQueue = function( model ) {\n\t\t\t\tif ( model === dit ) {\n\t\t\t\t\tdit._deferProcessing = false;\n\t\t\t\t\tdit.processQueue();\n\t\t\t\t\tcollection.off( 'relational:add', processQueue );\n\t\t\t\t}\n\t\t\t};\n\t\t\tcollection.on( 'relational:add', processQueue );\n\n\t\t\t// So we do process the queue eventually, regardless of whether this model actually gets added to 'options.collection'.\n\t\t\t_.defer( function() {\n\t\t\t\tprocessQueue( dit );\n\t\t\t});\n\t\t}\n\n\t\tmodule.store.processOrphanRelations();\n\t\tmodule.store.listenTo( this, 'relational:unregister', module.store.unregister );\n\n\t\tthis._queue = new module.BlockingQueue();\n\t\tthis._queue.block();\n\t\tmodule.eventQueue.block();\n\n\t\ttry {\n\t\t\tBackbone.Model.apply( this, arguments );\n\t\t}\n\t\tfinally {\n\t\t\t// Try to run the global queue holding external events\n\t\t\tmodule.eventQueue.unblock();\n\t\t}\n\t},\n\n\t/**\n\t * Override 'trigger' to queue 'change' and 'change:*' events\n\t */\n\ttrigger: function( eventName ) {\n\t\tif ( eventName.length > 5 && eventName.indexOf( 'change' ) === 0 ) {\n\t\t\tvar dit = this,\n\t\t\t\targs = arguments;\n\n\t\t\tif ( !module.eventQueue.isLocked() ) {\n\t\t\t\t// If we're not in a more complicated nested scenario, fire the change event right away\n\t\t\t\tBackbone.Model.prototype.trigger.apply( dit, args );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmodule.eventQueue.add( function() {\n\t\t\t\t\t// Determine if the `change` event is still valid, now that all relations are populated\n\t\t\t\t\tvar changed = true;\n\t\t\t\t\tif ( eventName === 'change' ) {\n\t\t\t\t\t\t// `hasChanged` may have gotten reset by nested calls to `set`.\n\t\t\t\t\t\tchanged = dit.hasChanged() || dit._attributeChangeFired;\n\t\t\t\t\t\tdit._attributeChangeFired = false;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvar attr = eventName.slice( 7 ),\n\t\t\t\t\t\t\trel = dit.getRelation( attr );\n\n\t\t\t\t\t\tif ( rel ) {\n\t\t\t\t\t\t\t// If `attr` is a relation, `change:attr` get triggered from `Relation.onChange`.\n\t\t\t\t\t\t\t// These take precedence over `change:attr` events triggered by `Model.set`.\n\t\t\t\t\t\t\t// The relation sets a fourth attribute to `true`. If this attribute is present,\n\t\t\t\t\t\t\t// continue triggering this event; otherwise, it's from `Model.set` and should be stopped.\n\t\t\t\t\t\t\tchanged = ( args[ 4 ] === true );\n\n\t\t\t\t\t\t\t// If this event was triggered by a relation, set the right value in `this.changed`\n\t\t\t\t\t\t\t// (a Collection or Model instead of raw data).\n\t\t\t\t\t\t\tif ( changed ) {\n\t\t\t\t\t\t\t\tdit.changed[ attr ] = args[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// Otherwise, this event is from `Model.set`. If the relation doesn't report a change,\n\t\t\t\t\t\t\t// remove attr from `dit.changed` so `hasChanged` doesn't take it into account.\n\t\t\t\t\t\t\telse if ( !rel.changed ) {\n\t\t\t\t\t\t\t\tdelete dit.changed[ attr ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ( changed ) {\n\t\t\t\t\t\t\tdit._attributeChangeFired = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tchanged && Backbone.Model.prototype.trigger.apply( dit, args );\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\telse if ( eventName === 'destroy' ) {\n\t\t\tBackbone.Model.prototype.trigger.apply( this, arguments );\n\t\t\tmodule.store.unregister( this );\n\t\t}\n\t\telse {\n\t\t\tBackbone.Model.prototype.trigger.apply( this, arguments );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * Initialize Relations present in this.relations; determine the type (HasOne/HasMany), then creates a new instance.\n\t * Invoked in the first call so 'set' (which is made from the Backbone.Model constructor).\n\t */\n\tinitializeRelations: function( options ) {\n\t\tthis.acquire(); // Setting up relations often also involve calls to 'set', and we only want to enter this function once\n\t\tthis._relations = {};\n\n\t\t_.each( this.relations || [], function( rel ) {\n\t\t\tmodule.store.initializeRelation( this, rel, options );\n\t\t}, this );\n\n\t\tthis._isInitialized = true;\n\t\tthis.release();\n\t\tthis.processQueue();\n\t},\n\n\t/**\n\t * When new values are set, notify this model's relations (also if options.silent is set).\n\t * (called from `set`; Relation.setRelated locks this model before calling 'set' on it to prevent loops)\n\t * @param {Object} [changedAttrs]\n\t * @param {Object} [options]\n\t */\n\tupdateRelations: function( changedAttrs, options ) {\n\t\tif ( this._isInitialized && !this.isLocked() ) {\n\t\t\t_.each( this._relations, function( rel ) {\n\t\t\t\tif ( !changedAttrs || ( rel.keySource in changedAttrs || rel.key in changedAttrs ) ) {\n\t\t\t\t\t// Fetch data in `rel.keySource` if data got set in there, or `rel.key` otherwise\n\t\t\t\t\tvar value = this.attributes[ rel.keySource ] || this.attributes[ rel.key ],\n\t\t\t\t\t\tattr = changedAttrs && ( changedAttrs[ rel.keySource ] || changedAttrs[ rel.key ] );\n\n\t\t\t\t\t// Update a relation if its value differs from this model's attributes, or it's been explicitly nullified.\n\t\t\t\t\t// Which can also happen before the originally intended related model has been found (`val` is null).\n\t\t\t\t\tif ( rel.related !== value || ( value === null && attr === null ) ) {\n\t\t\t\t\t\tthis.trigger( 'relational:change:' + rel.key, this, value, options || {} );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Explicitly clear 'keySource', to prevent a leaky abstraction if 'keySource' differs from 'key'.\n\t\t\t\tif ( rel.keySource !== rel.key ) {\n\t\t\t\t\tdelete this.attributes[ rel.keySource ];\n\t\t\t\t}\n\t\t\t}, this );\n\t\t}\n\t},\n\n\t/**\n\t * Either add to the queue (if we're not initialized yet), or execute right away.\n\t */\n\tqueue: function( func ) {\n\t\tthis._queue.add( func );\n\t},\n\n\t/**\n\t * Process _queue\n\t */\n\tprocessQueue: function() {\n\t\tif ( this._isInitialized && !this._deferProcessing && this._queue.isBlocked() ) {\n\t\t\tthis._queue.unblock();\n\t\t}\n\t},\n\n\t/**\n\t * Get a specific relation.\n\t * @param {string} attr The relation key to look for.\n\t * @return {Backbone.Relation} An instance of 'Backbone.Relation', if a relation was found for 'attr', or null.\n\t */\n\tgetRelation: function( attr ) {\n\t\treturn this._relations[ attr ];\n\t},\n\n\t/**\n\t * Get all of the created relations.\n\t * @return {Backbone.Relation[]}\n\t */\n\tgetRelations: function() {\n\t\treturn _.values( this._relations );\n\t},\n\n\n\t/**\n\t * Get a list of ids that will be fetched on a call to `getAsync`.\n\t * @param {string|Backbone.Relation} attr The relation key to fetch models for.\n\t * @param [refresh=false] Add ids for models that are already in the relation, refreshing them?\n\t * @return {Array} An array of ids that need to be fetched.\n\t */\n\tgetIdsToFetch: function( attr, refresh ) {\n\t\tvar rel = attr instanceof module.Relation ? attr : this.getRelation( attr ),\n\t\t\tids = rel ? ( rel.keyIds && rel.keyIds.slice( 0 ) ) || ( ( rel.keyId || rel.keyId === 0 ) ? [ rel.keyId ] : [] ) : [];\n\n\t\t// On `refresh`, add the ids for current models in the relation to `idsToFetch`\n\t\tif ( refresh ) {\n\t\t\tvar models = rel.related && ( rel.related.models || [ rel.related ] );\n\t\t\t_.each( models, function( model ) {\n\t\t\t\tif ( model.id || model.id === 0 ) {\n\t\t\t\t\tids.push( model.id );\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn ids;\n\t},\n\n\t/**\n\t * Get related objects. Returns a single promise, which can either resolve immediately (if the related model[s])\n\t * are already present locally, or after fetching the contents of the requested attribute.\n\t * @param {string} attr The relation key to fetch models for.\n\t * @param {Object} [options] Options for 'Backbone.Model.fetch' and 'Backbone.sync'.\n\t * @param {Boolean} [options.refresh=false] Fetch existing models from the server as well (in order to update them).\n\t * @return {jQuery.Deferred} A jQuery promise object. When resolved, its `done` callback will be called with\n\t *  contents of `attr`.\n\t */\n\tgetAsync: function( attr, options ) {\n\t\t// Set default `options` for fetch\n\t\toptions = _.extend( { add: true, remove: false, refresh: false }, options );\n\n\t\tvar dit = this,\n\t\t\trequests = [],\n\t\t\trel = this.getRelation( attr ),\n\t\t\tidsToFetch = rel && this.getIdsToFetch( rel, options.refresh ),\n\t\t\tcoll = rel.related instanceof module.Collection ? rel.related : rel.relatedCollection;\n\n\t\tif ( idsToFetch && idsToFetch.length ) {\n\t\t\tvar models = [],\n\t\t\t\tcreatedModels = [],\n\t\t\t\tsetUrl,\n\t\t\t\tcreateModels = function() {\n\t\t\t\t\t// Find (or create) a model for each one that is to be fetched\n\t\t\t\t\tmodels = _.map( idsToFetch, function( id ) {\n\t\t\t\t\t\tvar model = rel.relatedModel.findModel( id );\n\n\t\t\t\t\t\tif ( !model ) {\n\t\t\t\t\t\t\tvar attrs = {};\n\t\t\t\t\t\t\tattrs[ rel.relatedModel.prototype.idAttribute ] = id;\n\t\t\t\t\t\t\tmodel = rel.relatedModel.findOrCreate( attrs, options );\n\t\t\t\t\t\t\tcreatedModels.push( model );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn model;\n\t\t\t\t\t}, this );\n\t\t\t\t};\n\n\t\t\t// Try if the 'collection' can provide a url to fetch a set of models in one request.\n\t\t\t// This assumes that when 'module.Collection.url' is a function, it can handle building of set urls.\n\t\t\t// To make sure it can, test if the url we got by supplying a list of models to fetch is different from\n\t\t\t// the one supplied for the default fetch action (without args to 'url').\n\t\t\tif ( coll instanceof module.Collection && _.isFunction( coll.url ) ) {\n\t\t\t\tvar defaultUrl = coll.url();\n\t\t\t\tsetUrl = coll.url( idsToFetch );\n\n\t\t\t\tif ( setUrl === defaultUrl ) {\n\t\t\t\t\tcreateModels();\n\t\t\t\t\tsetUrl = coll.url( models );\n\n\t\t\t\t\tif ( setUrl === defaultUrl ) {\n\t\t\t\t\t\tsetUrl = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( setUrl ) {\n\t\t\t\t// Do a single request to fetch all models\n\t\t\t\tvar opts = _.defaults(\n\t\t\t\t\t{\n\t\t\t\t\t\terror: function() {\n\t\t\t\t\t\t\t_.each( createdModels, function( model ) {\n\t\t\t\t\t\t\t\tmodel.trigger( 'destroy', model, model.collection, options );\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\toptions.error && options.error.apply( models, arguments );\n\t\t\t\t\t\t},\n\t\t\t\t\t\turl: setUrl\n\t\t\t\t\t},\n\t\t\t\t\toptions\n\t\t\t\t);\n\n\t\t\t\trequests = [ coll.fetch( opts ) ];\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Make a request per model to fetch\n\t\t\t\tif  ( !models.length ) {\n\t\t\t\t\tcreateModels();\n\t\t\t\t}\n\n\t\t\t\trequests = _.map( models, function( model ) {\n\t\t\t\t\tvar opts = _.defaults(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror: function() {\n\t\t\t\t\t\t\t\tif ( _.contains( createdModels, model ) ) {\n\t\t\t\t\t\t\t\t\tmodel.trigger( 'destroy', model, model.collection, options );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\toptions.error && options.error.apply( models, arguments );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\toptions\n\t\t\t\t\t);\n\t\t\t\t\treturn model.fetch( opts );\n\t\t\t\t}, this );\n\t\t\t}\n\t\t}\n\n\t\treturn this.deferArray(requests).then(\n\t\t\tfunction() {\n\t\t\t\treturn Backbone.Model.prototype.get.call( dit, attr );\n\t\t\t}\n\t\t);\n\t},\n\n\tdeferArray: function(deferArray) {\n\t\treturn Backbone.$.when.apply(null, deferArray);\n\t},\n\n\tset: function( key, value, options ) {\n\t\tmodule.eventQueue.block();\n\n\t\t// Duplicate backbone's behavior to allow separate key/value parameters, instead of a single 'attributes' object\n\t\tvar attributes,\n\t\t\tresult;\n\n\t\tif ( _.isObject( key ) || key == null ) {\n\t\t\tattributes = key;\n\t\t\toptions = value;\n\t\t}\n\t\telse {\n\t\t\tattributes = {};\n\t\t\tattributes[ key ] = value;\n\t\t}\n\n\t\ttry {\n\t\t\tvar id = this.id,\n\t\t\t\tnewId = attributes && this.idAttribute in attributes && attributes[ this.idAttribute ];\n\n\t\t\t// Check if we're not setting a duplicate id before actually calling `set`.\n\t\t\tmodule.store.checkId( this, newId );\n\n\t\t\tresult = Backbone.Model.prototype.set.apply( this, arguments );\n\n\t\t\t// Ideal place to set up relations, if this is the first time we're here for this model\n\t\t\tif ( !this._isInitialized && !this.isLocked() ) {\n\t\t\t\tthis.constructor.initializeModelHierarchy();\n\n\t\t\t\t// Only register models that have an id. A model will be registered when/if it gets an id later on.\n\t\t\t\tif ( newId || newId === 0 ) {\n\t\t\t\t\tmodule.store.register( this );\n\t\t\t\t}\n\n\t\t\t\tthis.initializeRelations( options );\n\t\t\t}\n\t\t\t// The store should know about an `id` update asap\n\t\t\telse if ( newId && newId !== id ) {\n\t\t\t\tmodule.store.update( this );\n\t\t\t}\n\n\t\t\tif ( attributes ) {\n\t\t\t\tthis.updateRelations( attributes, options );\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\t// Try to run the global queue holding external events\n\t\t\tmodule.eventQueue.unblock();\n\t\t}\n\n\t\treturn result;\n\t},\n\n\tclone: function() {\n\t\tvar attributes = _.clone( this.attributes );\n\t\tif ( !_.isUndefined( attributes[ this.idAttribute ] ) ) {\n\t\t\tattributes[ this.idAttribute ] = null;\n\t\t}\n\n\t\t_.each( this.getRelations(), function( rel ) {\n\t\t\tdelete attributes[ rel.key ];\n\t\t});\n\n\t\treturn new this.constructor( attributes );\n\t},\n\n\t/**\n\t * Convert relations to JSON, omits them when required\n\t */\n\ttoJSON: function( options ) {\n\t\t// If this Model has already been fully serialized in this branch once, return to avoid loops\n\t\tif ( this.isLocked() ) {\n\t\t\treturn this.id;\n\t\t}\n\n\t\tthis.acquire();\n\t\tvar json = Backbone.Model.prototype.toJSON.call( this, options );\n\n\t\tif ( this.constructor._superModel && !( this.constructor._subModelTypeAttribute in json ) ) {\n\t\t\tjson[ this.constructor._subModelTypeAttribute ] = this.constructor._subModelTypeValue;\n\t\t}\n\n\t\t_.each( this._relations, function( rel ) {\n\t\t\tvar related = json[ rel.key ],\n\t\t\t\tincludeInJSON = rel.options.includeInJSON,\n\t\t\t\tvalue = null;\n\n\t\t\tif ( includeInJSON === true ) {\n\t\t\t\tif ( related && _.isFunction( related.toJSON ) ) {\n\t\t\t\t\tvalue = related.toJSON( options );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( _.isString( includeInJSON ) ) {\n\t\t\t\tif ( related instanceof module.Collection ) {\n\t\t\t\t\tvalue = related.pluck( includeInJSON );\n\t\t\t\t}\n\t\t\t\telse if ( related instanceof Backbone.Model ) {\n\t\t\t\t\tvalue = related.get( includeInJSON );\n\t\t\t\t}\n\n\t\t\t\t// Add ids for 'unfound' models if includeInJSON is equal to (only) the relatedModel's `idAttribute`\n\t\t\t\tif ( includeInJSON === rel.relatedModel.prototype.idAttribute ) {\n\t\t\t\t\tif ( rel instanceof module.HasMany ) {\n\t\t\t\t\t\tvalue = value.concat( rel.keyIds );\n\t\t\t\t\t}\n\t\t\t\t\telse if ( rel instanceof module.HasOne ) {\n\t\t\t\t\t\tvalue = value || rel.keyId;\n\n\t\t\t\t\t\tif ( !value && !_.isObject( rel.keyContents ) ) {\n\t\t\t\t\t\t\tvalue = rel.keyContents || null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( _.isArray( includeInJSON ) ) {\n\t\t\t\tif ( related instanceof module.Collection ) {\n\t\t\t\t\tvalue = [];\n\t\t\t\t\trelated.each( function( model ) {\n\t\t\t\t\t\tvar curJson = {};\n\t\t\t\t\t\t_.each( includeInJSON, function( key ) {\n\t\t\t\t\t\t\tcurJson[ key ] = model.get( key );\n\t\t\t\t\t\t});\n\t\t\t\t\t\tvalue.push( curJson );\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse if ( related instanceof Backbone.Model ) {\n\t\t\t\t\tvalue = {};\n\t\t\t\t\t_.each( includeInJSON, function( key ) {\n\t\t\t\t\t\tvalue[ key ] = related.get( key );\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdelete json[ rel.key ];\n\t\t\t}\n\n\t\t\t// In case of `wait: true`, Backbone will simply push whatever's passed into `save` into attributes.\n\t\t\t// We'll want to get this information into the JSON, even if it doesn't conform to our normal\n\t\t\t// expectations of what's contained in it (no model/collection for a relation, etc).\n\t\t\tif ( value === null && options && options.wait ) {\n\t\t\t\tvalue = related;\n\t\t\t}\n\n\t\t\tif ( includeInJSON ) {\n\t\t\t\tjson[ rel.keyDestination ] = value;\n\t\t\t}\n\n\t\t\tif ( rel.keyDestination !== rel.key ) {\n\t\t\t\tdelete json[ rel.key ];\n\t\t\t}\n\t\t});\n\n\t\tthis.release();\n\t\treturn json;\n\t}\n},\n{\n\t/**\n\t *\n\t * @param superModel\n\t * @returns {Backbone.Relational.Model.constructor}\n\t */\n\tsetup: function( superModel ) {\n\t\t// We don't want to share a relations array with a parent, as this will cause problems with reverse\n\t\t// relations. Since `relations` may also be a property or function, only use slice if we have an array.\n\t\tthis.prototype.relations = ( this.prototype.relations || [] ).slice( 0 );\n\n\t\tthis._subModels = {};\n\t\tthis._superModel = null;\n\n\t\t// If this model has 'subModelTypes' itself, remember them in the store\n\t\tif ( this.prototype.hasOwnProperty( 'subModelTypes' ) ) {\n\t\t\tmodule.store.addSubModels( this.prototype.subModelTypes, this );\n\t\t}\n\t\t// The 'subModelTypes' property should not be inherited, so reset it.\n\t\telse {\n\t\t\tthis.prototype.subModelTypes = null;\n\t\t}\n\n\t\t// Initialize all reverseRelations that belong to this new model.\n\t\t_.each( this.prototype.relations || [], function( rel ) {\n\t\t\tif ( !rel.model ) {\n\t\t\t\trel.model = this;\n\t\t\t}\n\n\t\t\tif ( rel.reverseRelation && rel.model === this ) {\n\t\t\t\tvar preInitialize = true;\n\t\t\t\tif ( _.isString( rel.relatedModel ) ) {\n\t\t\t\t\t/**\n\t\t\t\t\t * The related model might not be defined for two reasons\n\t\t\t\t\t *  1. it is related to itself\n\t\t\t\t\t *  2. it never gets defined, e.g. a typo\n\t\t\t\t\t *  3. the model hasn't been defined yet, but will be later\n\t\t\t\t\t * In neither of these cases do we need to pre-initialize reverse relations.\n\t\t\t\t\t * However, for 3. (which is, to us, indistinguishable from 2.), we do need to attempt\n\t\t\t\t\t * setting up this relation again later, in case the related model is defined later.\n\t\t\t\t\t */\n\t\t\t\t\tvar relatedModel = module.store.getObjectByName( rel.relatedModel );\n\t\t\t\t\tpreInitialize = relatedModel && ( relatedModel.prototype instanceof module.Model );\n\t\t\t\t}\n\n\t\t\t\tif ( preInitialize ) {\n\t\t\t\t\tmodule.store.initializeRelation( null, rel );\n\t\t\t\t}\n\t\t\t\telse if ( _.isString( rel.relatedModel ) ) {\n\t\t\t\t\tmodule.store.addOrphanRelation( rel );\n\t\t\t\t}\n\t\t\t}\n\t\t}, this );\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * Create a 'Backbone.Model' instance based on 'attributes'.\n\t * @param {Object} attributes\n\t * @param {Object} [options]\n\t * @return {Backbone.Model}\n\t */\n\tbuild: function( attributes, options ) {\n\t\t// 'build' is a possible entrypoint; it's possible no model hierarchy has been determined yet.\n\t\tthis.initializeModelHierarchy();\n\n\t\t// Determine what type of (sub)model should be built if applicable.\n\t\tvar model = this._findSubModelType( this, attributes ) || this;\n\n\t\treturn new model( attributes, options );\n\t},\n\n\t/**\n\t * Determines what type of (sub)model should be built if applicable.\n\t * Looks up the proper subModelType in 'this._subModels', recursing into\n\t * types until a match is found.  Returns the applicable 'Backbone.Model'\n\t * or null if no match is found.\n\t * @param {Backbone.Model} type\n\t * @param {Object} attributes\n\t * @return {Backbone.Model}\n\t */\n\t_findSubModelType: function( type, attributes ) {\n\t\tif ( type._subModels && type.prototype.subModelTypeAttribute in attributes ) {\n\t\t\tvar subModelTypeAttribute = attributes[ type.prototype.subModelTypeAttribute ];\n\t\t\tvar subModelType = type._subModels[ subModelTypeAttribute ];\n\t\t\tif ( subModelType ) {\n\t\t\t\treturn subModelType;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Recurse into subModelTypes to find a match\n\t\t\t\tfor ( subModelTypeAttribute in type._subModels ) {\n\t\t\t\t\tsubModelType = this._findSubModelType( type._subModels[ subModelTypeAttribute ], attributes );\n\t\t\t\t\tif ( subModelType ) {\n\t\t\t\t\t\treturn subModelType;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t},\n\n\t/**\n\t *\n\t */\n\tinitializeModelHierarchy: function() {\n\t\t// Inherit any relations that have been defined in the parent model.\n\t\tthis.inheritRelations();\n\n\t\t// If we came here through 'build' for a model that has 'subModelTypes' then try to initialize the ones that\n\t\t// haven't been resolved yet.\n\t\tif ( this.prototype.subModelTypes ) {\n\t\t\tvar resolvedSubModels = _.keys( this._subModels );\n\t\t\tvar unresolvedSubModels = _.omit( this.prototype.subModelTypes, resolvedSubModels );\n\t\t\t_.each( unresolvedSubModels, function( subModelTypeName ) {\n\t\t\t\tvar subModelType = module.store.getObjectByName( subModelTypeName );\n\t\t\t\tsubModelType && subModelType.initializeModelHierarchy();\n\t\t\t});\n\t\t}\n\t},\n\n\tinheritRelations: function() {\n\t\t// Bail out if we've been here before.\n\t\tif ( !_.isUndefined( this._superModel ) && !_.isNull( this._superModel ) ) {\n\t\t\treturn;\n\t\t}\n\t\t// Try to initialize the _superModel.\n\t\tmodule.store.setupSuperModel( this );\n\n\t\t// If a superModel has been found, copy relations from the _superModel if they haven't been inherited automatically\n\t\t// (due to a redefinition of 'relations').\n\t\tif ( this._superModel ) {\n\t\t\t// The _superModel needs a chance to initialize its own inherited relations before we attempt to inherit relations\n\t\t\t// from the _superModel. You don't want to call 'initializeModelHierarchy' because that could cause sub-models of\n\t\t\t// this class to inherit their relations before this class has had chance to inherit it's relations.\n\t\t\tthis._superModel.inheritRelations();\n\t\t\tif ( this._superModel.prototype.relations ) {\n\t\t\t\t// Find relations that exist on the '_superModel', but not yet on this model.\n\t\t\t\tvar inheritedRelations = _.filter( this._superModel.prototype.relations || [], function( superRel ) {\n\t\t\t\t\treturn !_.any( this.prototype.relations || [], function( rel ) {\n\t\t\t\t\t\treturn superRel.relatedModel === rel.relatedModel && superRel.key === rel.key;\n\t\t\t\t\t}, this );\n\t\t\t\t}, this );\n\n\t\t\t\tthis.prototype.relations = inheritedRelations.concat( this.prototype.relations );\n\t\t\t}\n\t\t}\n\t\t// Otherwise, make sure we don't get here again for this type by making '_superModel' false so we fail the\n\t\t// isUndefined/isNull check next time.\n\t\telse {\n\t\t\tthis._superModel = false;\n\t\t}\n\t},\n\n\t/**\n\t * Find an instance of `this` type in 'Backbone.store'.\n\t * A new model is created if no matching model is found, `attributes` is an object, and `options.create` is true.\n\t * - If `attributes` is a string or a number, `findOrCreate` will query the `store` and return a model if found.\n\t * - If `attributes` is an object and is found in the store, the model will be updated with `attributes` unless `options.merge` is `false`.\n\t * @param {Object|String|Number} attributes Either a model's id, or the attributes used to create or update a model.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.create=true]\n\t * @param {Boolean} [options.merge=true]\n\t * @param {Boolean} [options.parse=false]\n\t * @return {Backbone.Relational.Model}\n\t */\n\tfindOrCreate: function( attributes, options ) {\n\t\toptions || ( options = {} );\n\t\tvar parsedAttributes = ( _.isObject( attributes ) && options.parse && this.prototype.parse ) ?\n\t\t\tthis.prototype.parse( _.clone( attributes ), options ) : attributes;\n\n\t\t// If specified, use a custom `find` function to match up existing models to the given attributes.\n\t\t// Otherwise, try to find an instance of 'this' model type in the store\n\t\tvar model = this.findModel( parsedAttributes );\n\n\t\t// If we found an instance, update it with the data in 'item' (unless 'options.merge' is false).\n\t\t// If not, create an instance (unless 'options.create' is false).\n\t\tif ( _.isObject( attributes ) ) {\n\t\t\tif ( model && options.merge !== false ) {\n\t\t\t\t// Make sure `options.collection` and `options.url` doesn't cascade to nested models\n\t\t\t\tdelete options.collection;\n\t\t\t\tdelete options.url;\n\n\t\t\t\tmodel.set( parsedAttributes, options );\n\t\t\t}\n\t\t\telse if ( !model && options.create !== false ) {\n\t\t\t\tmodel = this.build( parsedAttributes, _.defaults( { parse: false }, options ) );\n\t\t\t}\n\t\t}\n\n\t\treturn model;\n\t},\n\n\t/**\n\t * Find an instance of `this` type in 'Backbone.store'.\n\t * - If `attributes` is a string or a number, `find` will query the `store` and return a model if found.\n\t * - If `attributes` is an object and is found in the store, the model will be updated with `attributes` unless `options.merge` is `false`.\n\t * @param {Object|String|Number} attributes Either a model's id, or the attributes used to create or update a model.\n\t * @param {Object} [options]\n\t * @param {Boolean} [options.merge=true]\n\t * @param {Boolean} [options.parse=false]\n\t * @return {Backbone.Relational.Model}\n\t */\n\tfind: function( attributes, options ) {\n\t\toptions || ( options = {} );\n\t\toptions.create = false;\n\t\treturn this.findOrCreate( attributes, options );\n\t},\n\n\t/**\n\t * A hook to override the matching when updating (or creating) a model.\n\t * The default implementation is to look up the model by id in the store.\n\t * @param {Object} attributes\n\t * @returns {Backbone.Relational.Model}\n\t */\n\tfindModel: function( attributes ) {\n\t\treturn module.store.find( this, attributes );\n\t}\n});\n\n/**\n * Override module.Collection._prepareModel, so objects will be built using the correct type\n * if the collection.model has subModels.\n * Attempts to find a model for `attrs` in Backbone.store through `findOrCreate`\n * (which sets the new properties on it if found), or instantiates a new model.\n */\nmodule.Collection.prototype.__prepareModel = module.Collection.prototype._prepareModel;\nmodule.Collection.prototype._prepareModel = function( attrs, options ) {\n\tvar model;\n\n\tif ( attrs instanceof Backbone.Model ) {\n\t\tif ( !attrs.collection ) {\n\t\t\tattrs.collection = this;\n\t\t}\n\t\tmodel = attrs;\n\t}\n\telse {\n\t\toptions = options ? _.clone( options ) : {};\n\t\toptions.collection = this;\n\n\t\tif ( typeof this.model.findOrCreate !== 'undefined' ) {\n\t\t\tmodel = this.model.findOrCreate( attrs, options );\n\t\t}\n\t\telse {\n\t\t\tmodel = new this.model( attrs, options );\n\t\t}\n\n\t\tif ( model && model.validationError ) {\n\t\t\tthis.trigger( 'invalid', this, attrs, options );\n\t\t\tmodel = false;\n\t\t}\n\t}\n\n\treturn model;\n};\n\n\n/**\n * Override module.Collection.set, so we'll create objects from attributes where required,\n * and update the existing models. Also, trigger 'relational:add'.\n */\nvar set = module.Collection.prototype.__set = module.Collection.prototype.set;\nmodule.Collection.prototype.set = function( models, options ) {\n\t// Short-circuit if this Collection doesn't hold RelationalModels\n\tif ( !( this.model.prototype instanceof module.Model ) ) {\n\t\treturn set.call( this, models, options );\n\t}\n\n\tif ( options && options.parse ) {\n\t\tmodels = this.parse( models, options );\n\t}\n\n\tvar singular = !_.isArray( models ),\n\t\tnewModels = [],\n\t\ttoAdd = [],\n\t\tmodel = null;\n\n\tmodels = singular ? ( models ? [ models ] : [] ) : _.clone( models );\n\n\t//console.debug( 'calling add on coll=%o; model=%o, options=%o', this, models, options );\n\tfor ( var i = 0; i < models.length; i++ ) {\n\t\tmodel = models[i];\n\t\tif ( !( model instanceof Backbone.Model ) ) {\n\t\t\tmodel = module.Collection.prototype._prepareModel.call( this, model, options );\n\t\t}\n\n\t\tif ( model ) {\n\t\t\ttoAdd.push( model );\n\n\t\t\tif ( !( this.get( model ) || this.get( model.cid ) ) ) {\n\t\t\t\tnewModels.push( model );\n\t\t\t}\n\t\t\t// If we arrive in `add` while performing a `set` (after a create, so the model gains an `id`),\n\t\t\t// we may get here before `_onModelEvent` has had the chance to update `_byId`.\n\t\t\telse if ( model.id != null ) {\n\t\t\t\tthis._byId[ model.id ] = model;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Add 'models' in a single batch, so the original add will only be called once (and thus 'sort', etc).\n\t// If `parse` was specified, the collection and contained models have been parsed now.\n\ttoAdd = singular ? ( toAdd.length ? toAdd[ 0 ] : null ) : toAdd;\n\tvar result = set.call( this, toAdd, _.defaults( { merge: false, parse: false }, options ) );\n\n\tfor ( i = 0; i < newModels.length; i++ ) {\n\t\tmodel = newModels[i];\n\t\t// Fire a `relational:add` event for any model in `newModels` that has actually been added to the collection.\n\t\tif ( this.get( model ) || this.get( model.cid ) ) {\n\t\t\tthis.trigger( 'relational:add', model, this, options );\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Override 'Backbone.Collection._removeModels' to trigger 'relational:remove'.\n */\nvar _removeModels = Backbone.Collection.prototype.___removeModels = Backbone.Collection.prototype._removeModels;\nBackbone.Collection.prototype._removeModels = function( models, options ) {\n\t// Short-circuit if this Collection doesn't hold RelationalModels\n\tif ( !( this.model.prototype instanceof module.Model ) ) {\n\t\treturn _removeModels.call( this, models, options );\n\t}\n\n\tvar toRemove = [];\n\n\t//console.debug('calling remove on coll=%o; models=%o, options=%o', this, models, options );\n\t_.each( models, function( model ) {\n\t\tmodel = this.get( model ) || ( model && this.get( model.cid ) );\n\t\tmodel && toRemove.push( model );\n\t}, this );\n\n\tvar result = _removeModels.call( this, toRemove, options );\n\n\t_.each( toRemove, function( model ) {\n\t\tthis.trigger( 'relational:remove', model, this, options );\n\t}, this );\n\n\treturn result;\n};\n\n/**\n * Override 'module.Collection.reset' to trigger 'relational:reset'.\n */\nvar reset = module.Collection.prototype.__reset = module.Collection.prototype.reset;\nmodule.Collection.prototype.reset = function( models, options ) {\n\toptions = _.extend( { merge: true }, options );\n\tvar result = reset.call( this, models, options );\n\n\tif ( this.model.prototype instanceof module.Model ) {\n\t\tthis.trigger( 'relational:reset', this, options );\n\t}\n\n\treturn result;\n};\n\n/**\n * Override 'module.Collection.sort' to trigger 'relational:reset'.\n */\nvar sort = module.Collection.prototype.__sort = module.Collection.prototype.sort;\nmodule.Collection.prototype.sort = function( options ) {\n\tvar result = sort.call( this, options );\n\n\tif ( this.model.prototype instanceof module.Model ) {\n\t\tthis.trigger( 'relational:reset', this, options );\n\t}\n\n\treturn result;\n};\n\n/**\n * Override 'module.Collection.trigger' so 'add', 'remove' and 'reset' events are queued until relations\n * are ready.\n */\nvar trigger = module.Collection.prototype.__trigger = module.Collection.prototype.trigger;\nmodule.Collection.prototype.trigger = function( eventName ) {\n\t// Short-circuit if this Collection doesn't hold RelationalModels\n\tif ( !( this.model.prototype instanceof module.Model ) ) {\n\t\treturn trigger.apply( this, arguments );\n\t}\n\n\tif ( eventName === 'add' || eventName === 'remove' || eventName === 'reset' || eventName === 'sort' ) {\n\t\tvar dit = this,\n\t\t\targs = arguments;\n\n\t\tif ( _.isObject( args[ 3 ] ) ) {\n\t\t\targs = _.toArray( args );\n\t\t\t// the fourth argument is the option object.\n\t\t\t// we need to clone it, as it could be modified while we wait on the eventQueue to be unblocked\n\t\t\targs[ 3 ] = _.clone( args[ 3 ] );\n\t\t}\n\n\t\tmodule.eventQueue.add( function() {\n\t\t\ttrigger.apply( dit, args );\n\t\t});\n\t}\n\telse {\n\t\ttrigger.apply( this, arguments );\n\t}\n\n\treturn this;\n};\n\n// Override .extend() to automatically call .setup()\nmodule.Model.extend = function( protoProps, classProps ) {\n\tvar child = Backbone.Model.extend.apply( this, arguments );\n\n\tchild.setup( this );\n\n\treturn child;\n};\n\nexport default module;\n"],"sourceRoot":"/source/"}